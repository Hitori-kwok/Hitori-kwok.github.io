<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hitori的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hitori的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hitori的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Hitori之家"><meta property="og:type" content="blog"><meta property="og:title" content="Hitori的博客"><meta property="og:url" content="https://hitori-kwok.github.io/"><meta property="og:site_name" content="Hitori的博客"><meta property="og:description" content="Hitori之家"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hitori-kwok.github.io/img/og_image.png"><meta property="article:author" content="Hitori"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hitori-kwok.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hitori-kwok.github.io"},"headline":"Hitori的博客","image":["https://hitori-kwok.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Hitori"},"publisher":{"@type":"Organization","name":"Hitori的博客","logo":{"@type":"ImageObject","url":{"text":"","light":"/img/logo.svg","dark":"/img/logo.svg"}}},"description":"Hitori之家"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/logo.svg" alt="Hitori的博客" height="28"><img class="logo-img-dark" src="/img/logo.svg" alt="Hitori的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-07-04T02:42:00.000Z" title="2025/7/4 10:42:00">2025-07-04</time>发表</span><span class="level-item"><time dateTime="2025-07-04T00:21:06.922Z" title="2025/7/4 08:21:06">2025-07-04</time>更新</span><span class="level-item">23 分钟读完 (大约3386个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/07/04/Spring%20AI%20Alibaba%E6%80%BB%E7%BB%93/">Spring AI Alibaba总结</a></p><div class="content"><h1 id="对话模型-Chat-Model"><a href="#对话模型-Chat-Model" class="headerlink" title="对话模型(Chat Model)"></a>对话模型(Chat Model)</h1><p>对话模型（Chat Model）接收一系列消息（Message）作为输入，与模型 LLM 服务进行交互，并接收返回的聊天消息（Chat Message）作为输出。相比于普通的程序输入，模型的输入与输出消息（Message）不止支持纯字符文本，还支持包括语音、图片、视频等作为输入输出。同时，在 Spring AI Alibaba 中，消息中还支持包含不同的角色，帮助底层模型区分来自模型、用户和系统指令等的不同消息。</p>
<h3 id="提示（Prompt）"><a href="#提示（Prompt）" class="headerlink" title="提示（Prompt）"></a>提示（Prompt）</h3><p>Prompt 作为语言基础输入的基础，指导 AI 模型生成特定的输出。每个文本输入都有其角色。例如，系统角色用于告知模型如何行为并设定交互的背景。还有用户角色，通常是来自用户的输入。</p>
<h2 id="嵌入（Embedding）"><a href="#嵌入（Embedding）" class="headerlink" title="嵌入（Embedding）"></a>嵌入（Embedding）</h2><p>嵌入（Embedding）是文本、图像或视频的数值表示，能够捕捉输入之间的关系，Embedding通过将文本、图像和视频转换为称为向量（Vector）的浮点数数组来工作。这些向量旨在捕捉文本、图像和视频的含义，Embedding数组的长度称为向量的维度。</p>
<p>Embedding在实际应用中，特别是在检索增强生成（RAG）模式中，具有重要意义。它们使数据能够在语义空间中表示为点，这类似于欧几里得几何的二维空间，但在更高的维度中。这意味着，就像欧几里得几何中平面上的点可以根据其坐标的远近关系而接近或远离一样，在语义空间中，点的接近程度反映了意义的相似性。关于相似主题的句子在这个多维空间中的位置较近，就像图表上彼此靠近的点。</p>
<p>您可以将这个语义空间视为一个向量。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>token是 AI 模型工作原理的基石。输入时，模型将单词转换为token。输出时，它们将token转换回单词。</p>
<p>在英语中，一个token大约对应一个单词的 75%。作为参考，莎士比亚的全集总共约 90 万个单词，翻译过来大约有 120 万个token。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01ciNztT1nJCFhQodzH_!!6000000005068-2-tps-1345-246.png" alt="spring-ai-concepts-tokens"></p>
<p>也许更重要的是 “token &#x3D; 金钱”。在托管 AI 模型的背景下，您的费用由使用的token数量决定。输入和输出都会影响总token数量。</p>
<p>此外，模型还受到 token 限制，这会限制单个 API 调用中处理的文本量。此阈值通常称为“上下文窗口”。模型不会处理超出此限制的任何文本。</p>
<h2 id="将您的数据和-API-引入-AI-模型"><a href="#将您的数据和-API-引入-AI-模型" class="headerlink" title="将您的数据和 API 引入 AI 模型"></a>将您的数据和 API 引入 AI 模型</h2><p>如何让人工智能模型与不在训练集中的数据一同工作？</p>
<p>请注意，GPT 3.5&#x2F;4.0 数据集仅支持截止到 2021 年 9 月之前的数据。因此，该模型表示它不知道该日期之后的知识，因此它无法很好的应对需要用最新知识才能回答的问题。一个有趣的小知识是，这个数据集大约有 650GB。</p>
<p>有三种技术可以定制 AI 模型以整合您的数据：</p>
<ul>
<li><p><code>Fine Tuning</code> 微调：这种传统的机器学习技术涉及定制模型并更改其内部权重。然而，即使对于机器学习专家来说，这是一个具有挑战性的过程，而且由于 GPT 等模型的大小，它极其耗费资源。此外，有些模型可能不提供此选项。</p>
</li>
<li><p><code>Prompt Stuffing</code> 提示词填充：一种更实用的替代方案是将您的数据嵌入到提供给模型的提示中。考虑到模型的令牌限制，我们需要具备过滤相关数据的能力，并将过滤出的数据填充到在模型交互的上下文窗口中，这种方法俗称“提示词填充”。Spring AI 库可帮助您基于“提示词填充” 技术，也称为<a target="_blank" rel="noopener" href="https://java2ai.com/docs/1.0.0.2/tutorials/basics/#%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90rag">检索增强生成 (RAG)</a>实现解决方案。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01hRUT291k1O09cdQEU_!!6000000004623-0-tps-3249-1230.jpg" alt="prompt-stuffing"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://java2ai.com/docs/1.0.0.2/tutorials/basics/tutorials/function-calling/">Function Calling</a>：此技术允许注册自定义的用户函数，将大型语言模型连接到外部系统的 API。Spring AI 大大简化了支持<a target="_blank" rel="noopener" href="https://java2ai.com/docs/1.0.0.2/tutorials/basics/tutorials/function-calling/">函数调用</a>所需编写的代码。</p>
</li>
</ul>
<h3 id="检索增强生成（RAG）"><a href="#检索增强生成（RAG）" class="headerlink" title="检索增强生成（RAG）"></a>检索增强生成（RAG）</h3><p><strong>一种称为检索增强生成 (RAG) 的技术已经出现，RAG为 AI 模型提供额外的知识输入，以辅助模型更好的回答问题。</strong></p>
<p>该方法涉及批处理式的编程模型，其中涉及到：从文档中读取非结构化数据、对其进行转换、然后将其写入矢量数据库。从高层次上讲，这是一个 ETL（提取、转换和加载）管道。矢量数据库则用于 RAG 技术的检索部分。</p>
<p>在将非结构化数据加载到矢量数据库的过程中，最重要的转换之一是将原始文档拆分成较小的部分。将原始文档拆分成较小部分的过程有<strong>两个重要步骤</strong>：</p>
<ol>
<li>将文档拆分成几部分，同时保留内容的语义边界。例如，对于包含段落和表格的文档，应避免在段落或表格中间拆分文档；对于代码，应避免在方法实现的中间拆分代码。</li>
<li>将文档的各部分进一步拆分成大小仅为 AI 模型令牌 token 限制的一小部分的部分。</li>
</ol>
<p>RAG 的下一个阶段是处理用户输入。当用户的问题需要由 AI 模型回答时，<strong>问题和所有“类似”的文档片段</strong>都会被放入发送给 AI 模型的提示中。这就是使用矢量数据库的原因，它非常擅长查找具有一定相似度的“类似”内容。</p>
<p><img src="https://img.alicdn.com/imgextra/i1/O1CN01zEQSHu1sQ8KTQSA2E_!!6000000005760-0-tps-3360-1859.jpg" alt="Spring AI RAG"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/etl-pipeline.html">ETL 管道</a> 提供了有关协调从数据源提取数据并将其存储在结构化向量存储中的流程的更多信息，确保在将数据传递给 AI 模型时数据具有最佳的检索格式。</li>
<li><a target="_blank" rel="noopener" href="https://java2ai.com/docs/1.0.0-M5.1/tutorials/chat-client/#%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90rag">ChatClient - RAG</a> 解释了如何使用<code>QuestionAnswerAdvisor</code> Advisor 在您的应用程序中启用 RAG 功能。</li>
</ul>
<h3 id="函数调用（Function-Calling）"><a href="#函数调用（Function-Calling）" class="headerlink" title="函数调用（Function Calling）"></a>函数调用（Function Calling）</h3><p>大型语言模型 (LLM) 在训练后即被冻结，导致知识陈旧，并且无法访问或修改外部数据。</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/functions.html">Function Calling</a>机制解决了这些缺点，<strong>它允许您注册自己的函数</strong>，<strong>以将大型语言模型连接到外部系统的 API。</strong>这些系统可以为 LLM 提供实时数据并代表它们执行数据处理操作。</p>
<p>Spring AI 大大简化了您需要编写的代码以支持函数调用。它为您处理函数调用对话。<strong>您可以将函数以一个Bean的形式供模型调用，<code>@Bean</code>然后在提示选项中提供该函数的 bean 名称以激活该函数。</strong>此外，您可以在单个提示中定义和引用多个函数。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/O1CN01kiQh6L1hnWmm5gCAW_!!6000000004322-0-tps-3400-1838.jpg" alt="Spring AI Function Calling"></p>
<ul>
<li>（1）执行聊天请求并发送函数定义信息。后者提供<code>name</code>（<code>description</code>例如，解释模型何时应调用该函数）和<code>input parameters</code>（例如，函数的输入参数模式）。</li>
<li>（2）当模型决定调用该函数时，它将使用输入参数调用该函数，并将输出返回给模型。</li>
<li>（3）Spring AI 为您处理此对话。它将函数调用分派给适当的函数，并将结果返回给模型。</li>
<li>（4）模型可以执行多个函数调用来检索所需的所有信息。</li>
<li>（5）一旦获取了所有需要的信息，模型就会生成响应。</li>
</ul>
<h3 id="顾问（Advisors）"><a href="#顾问（Advisors）" class="headerlink" title="顾问（Advisors）"></a>顾问（Advisors）</h3><p>Spring AI ChatClient 的一个关键特性是 Advisor API。<strong>这是一个拦截器链设计模式</strong>，允许你通过注入检索数据（Retrieval Context）和对话历史（Chat Memory）来修改传入的 Prompt。</p>
<p>Spring AI Alibaba 中的 <strong>Advisors</strong> 是框架提供的核心组件之一，<strong>用于拦截、修改和增强与大语言模型（LLM）的交互流程</strong>。其设计灵感来源于 Spring AOP 的 Advisor，但作用对象为 AI 模型请求和响应，而非传统业务方法。以下是其核心特性和应用场景的详细解析：</p>
<hr>
<h3 id="一、Advisor-的核心概念"><a href="#一、Advisor-的核心概念" class="headerlink" title="一、Advisor 的核心概念"></a><strong>一、Advisor 的核心概念</strong></h3><ol>
<li><strong>功能定位</strong><ul>
<li><strong>拦截与增强</strong>：Advisor 通过拦截 <code>AdvisedRequest</code> 和 <code>AdvisedResponse</code>，实现对模型输入（Prompt）和输出（ChatResponse）的修改或增强，例如添加日志、上下文记忆、敏感词过滤等<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,3</a>。</li>
<li><strong>链式调用</strong>：多个 Advisor 按优先级（<code>getOrder()</code> 值）组成链式结构，依次处理请求，最后将请求发送给 LLM<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>。</li>
</ul>
</li>
<li><strong>分类</strong><ul>
<li><strong>非流式 Advisor</strong>（<code>CallAroundAdvisor</code>）：适用于同步调用场景，如日志记录、权限校验。</li>
<li><strong>流式 Advisor</strong>（<code>StreamAroundAdvisor</code>）：用于流式响应（如 <code>Flux&lt;AdvisedResponse&gt;</code>），支持实时处理部分生成结果<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、内置-Advisor-及功能"><a href="#二、内置-Advisor-及功能" class="headerlink" title="二、内置 Advisor 及功能"></a><strong>二、内置 Advisor 及功能</strong></h3><p>Spring AI Alibaba 提供多种开箱即用的 Advisor，覆盖常见需求：</p>
<ol>
<li><p><strong>会话记忆类</strong></p>
<ul>
<li><p>**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageChatMemoryAdvisor</span><br></pre></td></tr></table></figure>

<p>**：将用户提问和模型回答存入内存，实现多轮对话上下文管理。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">ChatClient chatClient(ChatClient.Builder builder, ChatMemory memory) &#123;</span><br><span class="line">    return builder.defaultAdvisors(new MessageChatMemoryAdvisor(memory)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时需指定 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chatId</span><br></pre></td></tr></table></figure>

<p> 区分不同会话</p>
<p>3,5</p>
<p>。</p>
</li>
<li><p>**<code>PromptChatMemoryAdvisor</code>**：将历史会话嵌入系统提示词，兼容不支持上下文的模型<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>。</p>
</li>
<li><p>**<code>VectorStoreChatMemoryAdvisor</code>**：基于向量数据库（如 <code>SimpleVectorStore</code>）持久化会话，支持长期记忆和检索<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>。</p>
</li>
</ul>
</li>
<li><p><strong>检索增强类</strong></p>
<ul>
<li>**<code>QuestionAnswerAdvisor</code>**：结合 RAG（检索增强生成），从外部文档库检索相关内容并注入提示词，提升回答准确性<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,4</a>。</li>
</ul>
</li>
<li><p><strong>安全与日志类</strong></p>
<ul>
<li>**<code>SafeGuardAdvisor</code>**：拦截敏感词（如违禁词列表），阻止违规请求继续处理<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>。</li>
<li>**<code>SimpleLoggerAdvisor</code>**：记录请求和响应的日志，便于调试<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">3,4</a>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、Advisor-的配置与使用"><a href="#三、Advisor-的配置与使用" class="headerlink" title="三、Advisor 的配置与使用"></a><strong>三、Advisor 的配置与使用</strong></h3><ol>
<li><p><strong>基础配置</strong></p>
<ul>
<li><p>通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChatClient.Builder</span><br></pre></td></tr></table></figure>

<p> 注入 Advisor：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">ChatClient chatClient(ChatClient.Builder builder) &#123;</span><br><span class="line">    return builder.defaultAdvisors(</span><br><span class="line">        new SimpleLoggerAdvisor(),</span><br><span class="line">        new MessageChatMemoryAdvisor(new InMemoryChatMemory())</span><br><span class="line">    ).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3,5</p>
</li>
</ul>
</li>
<li><p><strong>动态调用</strong><br> 在每次请求中动态指定 Advisor 参数（如会话 ID）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chatClient.prompt(input)</span><br><span class="line">    .advisors(a -&gt; a.param(&quot;chatMemoryConversationId&quot;, &quot;user123&quot;))</span><br><span class="line">    .call();</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">3</a></p>
</li>
<li><p><strong>自定义 Advisor</strong><br> 实现 <code>CallAroundAdvisor</code> 或 <code>StreamAroundAdvisor</code> 接口，覆盖 <code>aroundCall</code>&#x2F;<code>aroundStream</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CustomAdvisor implements CallAroundAdvisor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) &#123;</span><br><span class="line">        // 修改请求或响应</span><br><span class="line">        return chain.nextAroundCall(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a></p>
</li>
</ol>
<hr>
<h3 id="四、Advisor-的应用场景"><a href="#四、Advisor-的应用场景" class="headerlink" title="四、Advisor 的应用场景"></a><strong>四、Advisor 的应用场景</strong></h3><ol>
<li><strong>多轮对话</strong>：通过 <code>MessageChatMemoryAdvisor</code> 实现上下文连贯性<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">3</a>。</li>
<li><strong>知识增强</strong>：结合 <code>QuestionAnswerAdvisor</code> 和 RAG，回答专业问题<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">4</a>。</li>
<li><strong>安全合规</strong>：使用 <code>SafeGuardAdvisor</code> 过滤敏感内容<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2</a>。</li>
<li><strong>性能监控</strong>：自定义 Advisor 统计模型调用耗时<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">5</a>。</li>
</ol>
<hr>
<h3 id="五、与其他组件的协同"><a href="#五、与其他组件的协同" class="headerlink" title="五、与其他组件的协同"></a><strong>五、与其他组件的协同</strong></h3><ul>
<li><strong>与 <code>ChatClient</code> 集成</strong>：Advisor 作为模型调用的中间件，可组合使用（如记忆+检索+日志）<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">1,5</a>。</li>
<li><strong>与 <code>ChatMemory</code> 结合</strong>：持久化会话到数据库或向量存储，支持长期记忆<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,3</a>。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Spring AI Alibaba 的 Advisor 机制通过拦截器和链式调用，为 AI 应用提供了灵活的增强能力，尤其适合需要上下文管理、安全控制或知识检索的场景。开发者可通过内置 Advisor 快速实现功能，或自定义扩展以满足复杂需求<a target="_blank" rel="noopener" href="https://tencent.yuanbao/@ref">2,5</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChatClient <span class="title function_">chatClient</span><span class="params">(ChatModel chatModel, VectorStore vectorStore, ChatMemory chatMemory)</span>&#123;</span><br><span class="line">        <span class="type">ChatClient</span> <span class="variable">client</span> <span class="operator">=</span> ChatClient.builder(chatModel)</span><br><span class="line">                <span class="comment">//背景设定</span></span><br><span class="line">                .defaultSystem(<span class="string">&quot;你是一个客服,请根据用户的问题给出合适的回答&quot;</span>)</span><br><span class="line">                .defaultAdvisors(</span><br><span class="line"><span class="comment">//                        QuestionAnswerAdvisor基于向量存储(VectorStore)的问答顾问</span></span><br><span class="line"><span class="comment">//                        topK(4)：表示返回最相关的4个结果</span></span><br><span class="line"><span class="comment">//                        similarityThresholdAll()：设置相似度阈值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">QuestionAnswerAdvisor</span>(vectorStore, SearchRequest.builder().topK(<span class="number">4</span>).similarityThresholdAll().build()),</span><br><span class="line"><span class="comment">//                        PromptChatMemoryAdvisor：管理对话记忆的顾问</span></span><br><span class="line"><span class="comment">//                        使用ChatMemory保存对话上下文，实现多轮对话</span></span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">PromptChatMemoryAdvisor</span>(chatMemory),</span><br><span class="line"><span class="comment">//                        SimpleLoggerAdvisor：简单的日志记录顾问</span></span><br><span class="line"><span class="comment">//                        可能用于记录对话过程或调试信息</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SimpleLoggerAdvisor</span>()</span><br><span class="line">                )</span><br><span class="line">                .defaultTools(<span class="string">&quot;getOrderFunction&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-20T02:42:00.000Z" title="2024/6/20 10:42:00">2024-06-20</time>发表</span><span class="level-item"><time dateTime="2024-06-20T02:56:49.644Z" title="2024/6/20 10:56:49">2024-06-20</time>更新</span><span class="level-item">1 小时读完 (大约9825个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/20/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/">SpringBootWeb请求响应</a></p><div class="content"><ul>
<li>请求Request<ul>
<li>必须掌握各种请求参数的映射规则</li>
</ul>
</li>
<li>响应Response<ul>
<li>了解后台响应前端的形式：Jsp和JSON</li>
<li>必须掌握JSON响应方式</li>
<li>掌握前后端分离统一响应的处理方式</li>
</ul>
</li>
<li>请求响应综合应用<ul>
<li>必须掌握雇员列表展示综合应用</li>
</ul>
</li>
<li>分层架构<ul>
<li>必须掌握分层架构思想</li>
<li>知道解耦思想</li>
<li>必须掌握IoC和DI</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一次的课程中，我们开发了springbootweb的入门程序。 基于SpringBoot的方式开发一个web应用，浏览器发起请求 &#x2F;hello 后 ，给浏览器返回字符串 “Hello World ~”。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428132052814.png" style="zoom:80%;box-shadow:1px 0px 5px 5px lightgray" />

<p>其实呢，是我们在浏览器发起请求，请求了我们的后端web服务器(也就是内置的Tomcat)。而我们在开发web程序时呢，定义了一个控制器类Controller，请求会被部署在Tomcat中的Controller接收，然后Controller再给浏览器一个响应，响应一个字符串 “Hello World”。 而在请求响应的过程中是遵循HTTP协议的。</p>
<p>但是呢，这里要告诉大家的时，其实在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别 Servlet程序的。 那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？</p>
<p>其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428132636152.png" style="zoom:80%; box-shadow:0px 0px 5px 5px lightgray" />

<p>那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后呢将解析后的请求数据会传递给Servlet程序的HttpServletRequest对象，那也就意味着 HttpServletRequest 对象就可以获取到请求数据。 而Tomcat，还给Servlet程序传递了一个参数 HttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> HelloServlet <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response )</span> &#123;</span><br><span class="line">        <span class="comment">// 接受浏览器请求</span></span><br><span class="line">        <span class="comment">// 业务</span></span><br><span class="line">        <span class="comment">// 向浏览器响应数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那上述所描述的这种浏览器&#x2F;服务器的架构模式呢，我们称之为：BS架构。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428132951800.png" alt="image-20240428132951800" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p>• BS架构：Browser&#x2F;Server，浏览器&#x2F;服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。</p>
<p>那今天呢，我们的课程内容主要就围绕着：请求、响应进行。 今天课程内容，主要包含三个部分：</p>
<blockquote>
<ul>
<li>请求</li>
<li>响应</li>
<li>分层解耦</li>
</ul>
</blockquote>
<h2 id="一、请求-Request"><a href="#一、请求-Request" class="headerlink" title="一、请求 Request"></a>一、请求 Request</h2><p>在本章节呢，我们主要讲解，如何接收页面传递过来的请求数据。</p>
<p>之前我们课程中有提到当前最为主流的开发模式：前后端分离</p>
<p><img src="/../images/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/image-20240109173536351.png" alt="image-20240109173536351"></p>
<p>在这种模式下，前端技术人员基于”接口文档”，开发前端程序；后端技术人员也基于”接口文档”，开发后端程序。</p>
<p>由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？</p>
<p>方式1：像之前SpringBoot入门案例中一样，直接使用浏览器。在浏览器中输入地址，测试后端程序。</p>
<ul>
<li>弊端：在浏览器地址栏中输入地址这种方式都是GET请求，如何我们要用到POST请求怎么办呢？<ul>
<li>要解决POST请求，需要程序员自己编写前端代码（比较麻烦）</li>
</ul>
</li>
</ul>
<p>方式2：使用专业的接口测试工具（课程中我们使用Postman工具）</p>
<h3 id="1、简单参数"><a href="#1、简单参数" class="headerlink" title="1、简单参数"></a>1、简单参数</h3><p>简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。</p>
<img src="../images/SpringBootWeb请求响应/image-20240426234935863.png" style="zoom:80%;box-shadow:1px 0px 5px 5px lightgray" /> 

<p>那么在后端程序中，如何接收传递过来的普通参数数据呢？</p>
<p>我们在这里讲解两种方式：</p>
<ol>
<li>原始方式   </li>
<li>SpringBoot方式</li>
</ol>
<h4 id="1-1-原始方式-了解"><a href="#1-1-原始方式-了解" class="headerlink" title="1.1 原始方式 ( 了解 )"></a>1.1 原始方式 ( 了解 )</h4><p>在原始的Web程序当中，需要通过Servlet中提供的API——HttpServletRequest（请求对象）来获取请求的相关信息，比如获取请求参数。<strong>Tomcat接收到http请求时，把请求的相关信息封装到HttpServletRequest对象中</strong></p>
<p>在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明 HttpServletRequest 对象。然后就可以通过该对象来获取请求信息：</p>
<table>
<thead>
<tr>
<th>HttpServletRequest 常用方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>String getParameter( 参数名 )</td>
<td>从请求对象HttpServletRequest中获取请求参数的数据值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//原始方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="comment">// http://localhost:8080/simple?name=will&amp;age=10</span></span><br><span class="line">        <span class="comment">// 请求参数： name=will&amp;age=17   （有2个请求参数）</span></span><br><span class="line">        <span class="comment">// 第1个请求参数： name=will   参数名:name，参数值:will</span></span><br><span class="line">        <span class="comment">// 第2个请求参数： age=17      参数名:age , 参数值:17</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);<span class="comment">//name就是请求参数名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);<span class="comment">//age就是请求参数名</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);<span class="comment">//需要手动进行类型转换</span></span><br><span class="line">        System.out.println(name+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ⚠️ &#x3D;&#x3D;注意&#x3D;&#x3D;：以上这种方式，我们仅做了解。（在以后的开发中不会使用到）</p>
<h4 id="1-2-SpringBoot方式-掌握"><a href="#1-2-SpringBoot方式-掌握" class="headerlink" title="1.2 SpringBoot方式 ( 掌握 )"></a>1.2 SpringBoot方式 ( 掌握 )</h4><p>在Springboot的环境中，<strong>对原始的API进行了封装，接收参数的形式更加简单</strong>。 <strong>映射规则：如果是简单参数，参数名与形参变量名相同</strong>，定义同名的形参即可接收参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simple?name=will&amp;age=10</span></span><br><span class="line">    <span class="comment">// 请求参数： name=will&amp;age=17   （有2个请求参数）</span></span><br><span class="line">    <span class="comment">// 第1个请求参数： name=will   参数名:name，参数值:will</span></span><br><span class="line">    <span class="comment">// 第2个请求参数： age=17      参数名:age , 参数值:17</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//springboot方式: 形参名和请求参数名保持一致</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String name , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>postman测试( GET 请求)：</strong></p>
<img src="../images/SpringBootWeb请求响应/image-20240427100628256.png" style="zoom:80%;box-shadow:1px 0px 5px 5px lightgray" /> 

<p>那么，如何使用PostMan发送 POST请求呢？</p>
<p><strong>postman测试( POST请求 )：</strong></p>
<img src="../images/SpringBootWeb请求响应/image-20240427101140520.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p><strong>结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证&#x3D;&#x3D;请求参数名和Controller方法中的形参名保持一致&#x3D;&#x3D;，就可以获取到请求参数中的数据值。</strong></p>
<h4 id="1-3-参数名不一致"><a href="#1-3-参数名不一致" class="headerlink" title="1.3 参数名不一致"></a>1.3 参数名不一致</h4><p>如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simple?name=will&amp;age=10</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求参数名和形参名不相同</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String username , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：运行没有报错。 controller方法中的username值为：null，age值为20</p>
<ul>
<li>结论：对于简单参数来讲，请求参数名和controller方法中的形参名不一致时，无法接收到请求数据</li>
</ul>
<p>那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？</p>
<p>解决方案：可以使用Spring提供的**@RequestParam**注解完成映射</p>
<p>在方法形参前面加上 @RequestParam 然后通过value属性设置请求参数名，从而完成映射。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simple&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、实体参数"><a href="#2、实体参数" class="headerlink" title="2、实体参数"></a>2、实体参数</h3><p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。 </p>
<p>此时，我们可以考虑将请求参数封装到一个实体类对象中。 要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong></p>
<img src="../images/SpringBootWeb请求响应/image-20240427103131221.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<h4 id="2-1-简单实体对象"><a href="#2-1-简单实体对象" class="headerlink" title="2.1 简单实体对象"></a>2.1 简单实体对象</h4><p>定义User实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/entity&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">entity</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Postman测试：</p>
<ul>
<li><p>参数名和实体类属性名一致时，可以映射成功 </p>
</li>
<li><p>参数名和实体类属性名不一致时，<strong>映射不到属性为null</strong></p>
</li>
</ul>
<h4 id="2-2-复杂实体对象"><a href="#2-2-复杂实体对象" class="headerlink" title="2.2 复杂实体对象"></a>2.2 复杂实体对象</h4><p>复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的，例如：User类中有一个Address类型的属性（Address是一个实体类）</p>
<p>复杂实体对象的封装，需要遵守如下规则：</p>
<ul>
<li><strong>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。</strong></li>
</ul>
<p>定义实体类：</p>
<ul>
<li>Address实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>User实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">// 地址数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&quot;</span> + address +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// 实体参数：复杂实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/entity&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">entity</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Postman测试：</p>
<img src="../images/SpringBootWeb请求响应/image-20240427104710315.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 





<h3 id="3、数组集合参数"><a href="#3、数组集合参数" class="headerlink" title="3、数组集合参数"></a>3、数组集合参数</h3><p>数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。</p>
<img src="../images/SpringBootWeb请求响应/image-20221203164114083.png"  style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p>多个值是怎么提交的呢？其实<strong>多个值也是一个一个的提交</strong>。</p>
<img src="../images/SpringBootWeb请求响应/image-20240427110010451.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p>后端程序接收上述多个值的方式有两种：</p>
<ol>
<li>数组</li>
<li>集合</li>
</ol>
<h4 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h4><p>数组参数：<strong>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p>
<img src="../images/SpringBootWeb请求响应/image-20240427110738590.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//数组集合参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/array&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">array</span><span class="params">(String[] hobby)</span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(hobby));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Postman测试：</p>
<p>在前端请求时，有两种传递形式：</p>
<p>方式一： xx?hobby&#x3D;game&amp;hobby&#x3D;java </p>
<p>方式二：xx?hobby&#x3D;game,java</p>
<img src="../images/SpringBootWeb请求响应/image-20240427110954816.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 



<h4 id="3-2-集合"><a href="#3-2-集合" class="headerlink" title="3.2 集合"></a>3.2 集合</h4><p>集合参数：<strong>请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系</strong></p>
<blockquote>
<p>默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系</p>
</blockquote>
<img src="../images/SpringBootWeb请求响应/image-20240427111856097.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hobby)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hobby = &quot;</span> + hobby);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Postman测试：请自行测试</p>
<p>方式一： xx?hobby&#x3D;game&amp;hobby&#x3D;java </p>
<p>方式二：xx?hobby&#x3D;game,java</p>
<h3 id="4、日期参数"><a href="#4、日期参数" class="headerlink" title="4、日期参数"></a>4、日期参数</h3><p>上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求：</p>
<img src="../images/SpringBootWeb请求响应/image-20240427112238054.png" alt="image-20240427112238054" style="zoom:80%;" /> 

<p>因为日期和时间格式多种多样（如：2024-04-27 10:05:45 、2024&#x2F;04&#x2F;27 10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过@DateTimeFormat注解，以及其pattern属性来设置日期的格式。</p>
<img src="../images/SpringBootWeb请求响应/image-20240427125638368.png"  style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<ul>
<li>@DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。</li>
<li>后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。</li>
</ul>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//日期时间参数</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">date</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> Date createTime)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;createTime = &quot;</span> + createTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、JSON参数"><a href="#5、JSON参数" class="headerlink" title="5、JSON参数"></a>5、JSON参数</h3><p>在学习前端技术时，我们有讲到过JSON，而在前后端进行交互时，如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式）</p>
<p>我们学习JSON格式参数，主要从以下两个方面着手：</p>
<ol>
<li>Postman在发送请求时，如何传递json格式的请求参数</li>
<li>在服务端的controller方法中，如何接收json格式的请求参数</li>
</ol>
<p>Postman发送JSON格式数据：</p>
<img src="../images/SpringBootWeb请求响应/image-20240427171739189.png" style="zoom:80%;box-shadow:0px 0px 5px 5px lightgray" /> 

<p>服务端Controller方法接收JSON格式数据：</p>
<ul>
<li>传递json格式的参数，在Controller中会使用实体类进行封装。 </li>
<li>封装规则：<strong>JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody标识。</strong></li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240427172248687.png" style="zoom:80%; box-shadow:0px 0px 5px 5px lightgray" /> 

<ul>
<li>@RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致）</li>
</ul>
<p>实体类：Address</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类：User</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//JSON参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">json</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、路径参数"><a href="#6、路径参数" class="headerlink" title="6、路径参数"></a>6、路径参数</h3><p>问题：传统的开发中，请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key&#x3D;value的形式传递(GET请求)。</p>
<p>在现在的开发中，经常还会直接在请求的URL中传递参数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/1		</span><br><span class="line">http://localhost:880/user/1/0</span><br></pre></td></tr></table></figure>

<p>上述的这种传递请求参数的形式呢，我们称之为：<strong>路径参数</strong></p>
<p>学习路径参数呢，主要掌握在后端的controller方法中，如何接收路径参数。</p>
<p>路径参数：</p>
<ul>
<li>前端：通过请求URL直接传递参数</li>
<li>后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数</li>
</ul>
<p><img src="/../images/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/image-20221204001520756.png" alt="image-20221204001520756"></p>
<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Postman测试：</p>
<p><img src="/../images/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/image-20221204002040184.png" alt="image-20221204002040184"></p>
<p><strong>传递多个路径参数：</strong> <a target="_blank" rel="noopener" href="http://localhost:8080/path/1/will">http://localhost:8080/path/1/will</a></p>
<p>PostMan：</p>
<img src="../images/SpringBootWeb请求响应/image-20240427172937265.png" alt="image-20240427172937265" style="zoom:80%;" /> 

<p>Controller方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, <span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(id+ <span class="string">&quot; : &quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="二、响应-Response"><a href="#二、响应-Response" class="headerlink" title="二、响应 Response"></a>二、响应 Response</h2><p>前面我们学习HTML协议的交互方式：请求响应模式（有请求就有响应）</p>
<p>那么Controller程序呢，除了接收请求外，还可以进行响应。 在Web项目后，响应的方式有2种，一种Jsp页面，一种是JSON数据</p>
<h3 id="1-响应-Jsp-页面"><a href="#1-响应-Jsp-页面" class="headerlink" title="1 响应 Jsp 页面"></a>1 响应 Jsp 页面</h3><p>需求：请求 <a target="_blank" rel="noopener" href="http://localhost:8080/list">http://localhost:8080/list</a> 时，响应一个部门列表。</p>
<img src="../images/SpringBootWeb请求响应/image-20240427195332311.png" alt="image-20240427195332311" style="zoom:80%;" />

<p>第一步：添加依赖。修改pom.xml 文件，添加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jsp页面使用jstl标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用jsp引擎，springboot内置tomcat没有此依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：创建webapp &#x2F; views 目录，存放视图文件</p>
<img src="../images/SpringBootWeb请求响应/image-20240427192203743.png" alt="image-20240427192203743" style="zoom:80%;" /> 

<p>第三步：配置视图文件前后缀。修改application.yml，添加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jsp 配置</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">mvc</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">view</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">prefix</span>: <span class="string">/views/   #配置视图文件的前缀</span></span><br><span class="line">      <span class="attr">suffix</span>: <span class="string">.jsp      #配置视图文件的后缀</span></span><br></pre></td></tr></table></figure>

<p>第三步：在views目录下创建 list.jsp </p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;雇员列表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;table width=<span class="string">&quot;600px&quot;</span> cellpadding=<span class="string">&quot;0&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> align=<span class="string">&quot;center&quot;</span> border=<span class="string">&quot;1px&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;ID&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;密码&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;EMail&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;年龄&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">1</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;will&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">123</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;will<span class="meta">@qq</span>.com&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;<span class="number">17</span>&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;删除&lt;/a&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;#&quot;</span>&gt;修改&lt;/a&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第四部：创建 ResponseController 控制台，添加 @Controller 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>list 方法返回值表示jsp页面的位置，return “list” 实际是简写的路径，完整的路径是：&#x2F;views&#x2F;list.jsp</p>
<p>目前 list.jsp 页面都是静态的html，如果需要动态的显示数据（来自数据库或文件中），我们可以做以下调整</p>
<p>定义 Employee 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean admin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改控制器，添加雇员对象数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employees = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1L</span>,<span class="string">&quot;will&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;will@qq.com&quot;</span>,<span class="number">17</span>, <span class="literal">true</span>));</span><br><span class="line">        employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2L</span>,<span class="string">&quot;alex&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;alex@qq.com&quot;</span>,<span class="number">18</span>, <span class="literal">false</span>));</span><br><span class="line">        model.addAttribute(<span class="string">&quot;employees&quot;</span>, employees);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 list. jsp</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;table width=<span class="string">&quot;600px&quot;</span> cellpadding=<span class="string">&quot;0&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span> align=<span class="string">&quot;center&quot;</span> border=<span class="string">&quot;1px&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;ID&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;密码&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;EMail&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;年龄&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;employees&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;emp&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.id&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.name&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.password&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.email&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;emp.age&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;#&quot;</span>&gt;删除&lt;/a&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;#&quot;</span>&gt;修改&lt;/a&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2-响应JSON数据"><a href="#2-响应JSON数据" class="headerlink" title="2 响应JSON数据"></a>2 响应JSON数据</h3><p>在我们前面所编写的controller方法中，都已经设置了响应数据。</p>
<img src="../images/SpringBootWeb请求响应/image-20240427201059224.png" alt="image-20240427201059224" style="zoom:80%;" /> 

<p>controller方法中的return的结果，怎么就可以响应给浏览器呢？</p>
<p>答案：使用@ResponseBody注解</p>
<p><strong>@ResponseBody注解：</strong></p>
<ul>
<li>位置：书写在Controller方法上或类上</li>
<li>作用：将方法返回值直接响应给浏览器<ul>
<li>如果返回值类型是字符串，直接把该字符串响应给浏览器</li>
<li>如果返回值类型是实体对象&#x2F;集合，将会转换为JSON格式后在响应给浏览器</li>
</ul>
</li>
</ul>
<p>但是在我们所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：在类上添加的@RestController注解，是一个组合注解。</p>
<ul>
<li>@RestController &#x3D; @Controller + @ResponseBody</li>
</ul>
<p>@RestController源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span>   <span class="comment">//元注解（修饰注解的注解）</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="comment">//元注解</span></span><br><span class="line"><span class="meta">@Documented</span>    <span class="comment">//元注解</span></span><br><span class="line"><span class="meta">@Controller</span>   </span><br><span class="line"><span class="meta">@ResponseBody</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Controller.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：在类上添加@RestController就相当于添加了@ResponseBody注解。</strong></p>
<ul>
<li>类上有@RestController注解或@ResponseBody注解时：表示当前类下所有的方法返回值做为响应数据<ul>
<li>方法的返回值，如果是字符串，直接把该字符串响应给浏览器</li>
<li>方法的返回值，如果是一个POJO对象或集合时，会先转换为JSON格式，在响应给浏览器</li>
</ul>
</li>
</ul>
<p>下面我们来测试下响应数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123;</span><br><span class="line">    <span class="comment">//响应字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//响应实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();<span class="comment">//创建实体类对象</span></span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//响应集合数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Address&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//集合对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr2.setProvince(<span class="string">&quot;陕西&quot;</span>);</span><br><span class="line">        addr2.setCity(<span class="string">&quot;西安&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.add(addr);</span><br><span class="line">        list.add(addr2);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端响应了一个对象或者集合，那私前端获取到的数据是什么样子的呢？我们使用postman发送请求来测试下。测试效果如下：</p>
<img src="../images/SpringBootWeb请求响应/image-20240427202101923.png" style="zoom:80%; box-shadow:0px 0px 5px 5px lightgray" /> 



<img src="../images/SpringBootWeb请求响应/image-20240427202207034.png" style="zoom:80%; box-shadow:0px 0px 5px 5px lightgray" /> 



<h3 id="3-统一响应结果"><a href="#3-统一响应结果" class="headerlink" title="3 统一响应结果"></a>3 统一响应结果</h3><p>大家有没有发现一个问题，我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。</p>
<img src="../images/SpringBootWeb请求响应/image-20221204174052622.png" alt="image-20221204174052622" style="zoom:80%;" />

<p>如果我们开发一个大型项目，项目中controller方法将成千上万，使用上述方式将造成整个项目难以维护。那在真实的项目开发中是什么样子的呢？</p>
<p>在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下：</p>
<img src="../images/SpringBootWeb请求响应/image-20221204174537686.png" alt="image-20221204174537686" style="zoom:80%;" />

<blockquote>
<p>前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。</p>
</blockquote>
<p>统一的返回结果使用类来描述，在这个结果中包含：</p>
<ul>
<li><p>响应状态码：当前请求是成功，还是失败</p>
</li>
<li><p>状态码信息：给页面的提示信息</p>
</li>
<li><p>返回的数据：给前端响应的数据（字符串、对象、集合）</p>
</li>
</ul>
<p>定义在一个实体类Result来包含以上信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//响应码，1 代表成功; 0 代表失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">//响应码 描述字符串</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增删改 成功响应(不需要给前端返回数据,也即不携带数据)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询 成功响应(把查询结果做为返回数据响应给前端，也即携带数据)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123; </span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="comment">//return new Result(1,&quot;success&quot;,&quot;Hello World ~&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">listAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Address&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr2.setProvince(<span class="string">&quot;陕西&quot;</span>);</span><br><span class="line">        addr2.setCity(<span class="string">&quot;西安&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.add(addr);</span><br><span class="line">        list.add(addr2);</span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Postman测试：</p>
<img src="../images/SpringBootWeb请求响应/image-20221204180946963.png" alt="image-20221204180946963" style="zoom:80%;" />

<img src="../images/SpringBootWeb请求响应/image-20221204180744084.png" alt="image-20221204180744084" style="zoom:80%;" />





<h2 id="三、请求响应综合应用"><a href="#三、请求响应综合应用" class="headerlink" title="三、请求响应综合应用"></a>三、请求响应综合应用</h2><p>下面我们通过一个案例，来加强对请求响应的学习。</p>
<h3 id="2-3-1-需求说明"><a href="#2-3-1-需求说明" class="headerlink" title="2.3.1 需求说明"></a>2.3.1 需求说明</h3><p>需求：加载并解析xml文件中的数据，完成数据处理，并在页面展示</p>
<img src="../images/SpringBootWeb请求响应/image-20240428100437429.png" alt="image-20240428100437429" style="zoom:80%;" />  

<ul>
<li>获取员工数据，返回统一响应结果，在页面渲染展示</li>
</ul>
<h3 id="2-3-2-准备工作"><a href="#2-3-2-准备工作" class="headerlink" title="2.3.2 准备工作"></a>2.3.2 准备工作</h3><p>案例准备：</p>
<p>1 XML文件</p>
<ul>
<li>已经准备好(emps.xml)，直接导入进来，放在 src&#x2F;main&#x2F;resources目录下</li>
</ul>
<p>2 工具类</p>
<ul>
<li>已经准备好解析XML文件的工具类，无需自己实现</li>
<li>直接在创建一个包 cn.wolfcode.utils ，然后将工具类拷贝进来</li>
</ul>
<p>3 前端页面资源</p>
<ul>
<li>已经准备好，直接拷贝进来，放在src&#x2F;main&#x2F;resources下的static目录下</li>
</ul>
<p>Springboot项目的静态资源(html，css，js等前端资源) 默认存放目录为：classpath:&#x2F;static 、 classpath:&#x2F;public、 classpath:&#x2F;resources</p>
<blockquote>
<p>在SpringBoot项目中，静态资源默认可以存放的目录：</p>
<ul>
<li>classpath:&#x2F;static&#x2F;</li>
<li>classpath:&#x2F;public&#x2F;</li>
<li>classpath:&#x2F;resources&#x2F;</li>
<li>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</li>
</ul>
<p>classpath：</p>
<ul>
<li>代表的是类路径，在maven的项目中，其实指的就是 src&#x2F;main&#x2F;resources 或者 src&#x2F;main&#x2F;java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在 src&#x2F;main&#x2F;resources下。</li>
</ul>
</blockquote>
<h3 id="2-3-3-实现步骤"><a href="#2-3-3-实现步骤" class="headerlink" title="2.3.3 实现步骤"></a>2.3.3 实现步骤</h3><p>1 在pom.xml文件中引入dom4j的依赖，用于解析XML文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2 引入资料中提供的：解析XML的工具类XMLParserUtils、实体类Empoyee、XML文件emps.xml</p>
<img src="../images/SpringBootWeb请求响应/image-20240427221201405.png" alt="image-20240427221201405" style="zoom:80%;" /> 

<p>3 引入资料中提供的静态页面文件，放在resources下的static目录下</p>
<img src="../images/SpringBootWeb请求响应/image-20240427221341941.png" alt="image-20240427221341941" style="zoom:80%;" /> 

<p>4、创建EmployeeController类，编写Controller程序，处理请求，响应数据</p>
<img src="../images/SpringBootWeb请求响应/image-20240427221457570.png" alt="image-20240427221457570" style="zoom:80%;" /> 



<h3 id="2-3-4-代码实现"><a href="#2-3-4-代码实现" class="headerlink" title="2.3.4 代码实现"></a>2.3.4 代码实现</h3><p>Contriller代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emps.xml&quot;</span>).getFile();</span><br><span class="line">        List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 对数据进行转换处理</span></span><br><span class="line">        employees.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">imageName</span> <span class="operator">=</span> emp.getImage();</span><br><span class="line">            emp.setImage(<span class="string">&quot;/imgs/&quot;</span> + imageName);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>统一返回结果实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code ;  <span class="comment">//1 成功 , 0 失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;     <span class="comment">//提示信息</span></span><br><span class="line">    <span class="keyword">private</span> Object data;    <span class="comment">//数据 data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, <span class="string">&quot;success&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-5-测试"><a href="#2-3-5-测试" class="headerlink" title="2.3.5 测试"></a>2.3.5 测试</h3><p>代码编写完毕之后，我们就可以运行引导类，启动服务进行测试了。 </p>
<p>使用Postman测试：</p>
<img src="../images/SpringBootWeb请求响应/image-20240428100823452.png" alt="image-20240428100823452" style="zoom:80%;" /> 

<p>打开浏览器，在浏览器地址栏输入： <a target="_blank" rel="noopener" href="http://localhost:8080/emp.html">http://localhost:8080/emp.html</a></p>
 <img src="../images/SpringBootWeb请求响应/image-20240428100844999.png" alt="image-20240428100844999" style="zoom:80%;" />





<h3 id="2-3-6-存在问题分析"><a href="#2-3-6-存在问题分析" class="headerlink" title="2.3.6 存在问题分析"></a>2.3.6 存在问题分析</h3><p>上述案例的功能，我们虽然已经实现，但是呢，我们会发现案例中：解析XML数据，获取数据的代码，处理数据的逻辑的代码，给页面响应的代码全部都堆积在一起了，全部都写在controller方法中了。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428103251458.png" alt="image-20240428103251458" style="zoom:80%;" /> 

<p>当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。</p>
<ul>
<li><p>当我们要修改操作数据部分的代码（例如：emps.xml换了位置），需要改动Controller</p>
</li>
<li><p>当我们要完善逻辑处理部分的代码，需要改动Controller</p>
</li>
<li><p>当我们需要修改数据响应的代码，还是需要改动Controller</p>
</li>
</ul>
<p>这样呢，就会造成我们整个工程代码的耦合性太大，进而导致复用性差，而且代码难以维护。 那如何解决这个问题呢？其实在现在的开发中，有非常成熟的解决思路，那就是分层开发。</p>
<h2 id="四、分层解耦"><a href="#四、分层解耦" class="headerlink" title="四、分层解耦"></a>四、分层解耦</h2><h3 id="1、三层架构"><a href="#1、三层架构" class="headerlink" title="1、三层架构"></a>1、三层架构</h3><h4 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h4><p>在我们进行程序设计以及程序开发时，<strong>尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）</strong>。</p>
<blockquote>
<p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p>
<p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p>
</blockquote>
<p>我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序：</p>
<img src="../images/SpringBootWeb请求响应/image-20240428104135172.png" alt="image-20240428104135172" style="zoom:80%;" /> 

<p>那其实我们上述案例的逻辑呢，从组成上看可以分为三个部分：</p>
<ul>
<li><strong>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作</strong></li>
<li><strong>逻辑处理：负责业务逻辑处理的代码</strong></li>
<li><strong>请求处理、响应数据：负责，接收页面的请求，给页面响应数据</strong></li>
</ul>
<p>按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：</p>
<img src="../images/SpringBootWeb请求响应/image-20240428104520467.png" alt="image-20240428104520467" style="zoom:80%;" />

<ul>
<li>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。</li>
<li>Service：业务逻辑层。处理具体的业务逻辑。</li>
<li>Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li>
</ul>
<p>基于三层架构的程序执行流程：</p>
<img src="../images/SpringBootWeb请求响应/image-20240428104941254.png" alt="image-20240428104941254" style="zoom:80%;" />

<ul>
<li>前端发起的请求，由Controller层接收（Controller响应数据给前端）</li>
<li>Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）</li>
<li>Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）</li>
<li>Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）</li>
</ul>
<blockquote>
<p>思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？ </p>
<p>答案：不会影响。 （程序的扩展性、维护性变得更好了）</p>
</blockquote>
<h4 id="1-2-代码拆分"><a href="#1-2-代码拆分" class="headerlink" title="1.2 代码拆分"></a>1.2 代码拆分</h4><p>我们使用三层架构思想，来改造下之前的程序：</p>
<ul>
<li>控制层包名：xx.controller</li>
<li>业务逻辑层包名：xx.service</li>
<li>数据访问层包名：xx.dao</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428110007495.png" alt="image-20240428110007495" style="zoom:80%;" /> 

<p><strong>控制层：</strong>接收前端发送的请求，对请求进行处理，并响应数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="comment">// 业务层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IEmployeeService</span> <span class="variable">employeeService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeServiceImplA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Employee&gt; employees = employeeService.list();</span><br><span class="line">        <span class="comment">//2 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>业务逻辑层：</strong>处理具体的业务逻辑</p>
<ul>
<li>业务接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑接口（制定业务规则、标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEmployeeService</span> &#123;</span><br><span class="line">    <span class="comment">//获取员工列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>业务实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑实现类（按照业务标准实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">IEmployeeService</span> &#123;</span><br><span class="line">	<span class="comment">// dao层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IEmployeeDao</span> <span class="variable">employeeDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeDaoImplA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employees = employeeDao.selectAll();</span><br><span class="line">        employees.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">imageName</span> <span class="operator">=</span> emp.getImage();</span><br><span class="line">            emp.setImage(<span class="string">&quot;/imgs/&quot;</span> + imageName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据访问层：</strong>负责数据的访问操作，包含数据的增、删、改、查</p>
<ul>
<li>数据访问接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问层接口（制定标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEmployeeDao</span> &#123;</span><br><span class="line">	<span class="comment">//获取员工列表数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据访问实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDaoImplA</span> <span class="keyword">implements</span> <span class="title class_">IEmployeeDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emps.xml&quot;</span>).getFile();</span><br><span class="line">        List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class);</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分层架构的流程图：画图</p>
<p>三层架构的好处：</p>
<ol>
<li>复用性强</li>
<li>便于维护</li>
<li>利用扩展</li>
</ol>
<h3 id="2、分层解耦"><a href="#2、分层解耦" class="headerlink" title="2、分层解耦"></a>2、分层解耦</h3><p>刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。</p>
<p>解耦：解除耦合。</p>
<h4 id="2-1-耦合问题"><a href="#2-1-耦合问题" class="headerlink" title="2.1 耦合问题"></a>2.1 耦合问题</h4><p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p>
<ul>
<li><p>内聚：软件中各个功能模块内部的功能联系。</p>
</li>
<li><p>耦合：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</p>
</li>
</ul>
<p><strong>软件设计原则：高内聚低耦合。</strong></p>
<blockquote>
<p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。</p>
<p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p>
</blockquote>
<p>程序中高内聚的体现：</p>
<ul>
<li>EmpServiceA类中只编写了和员工相关的逻辑处理代码</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428112239724.png" alt="image-20240428112239724" style="zoom:80%;" /> 

<p>程序中耦合代码的体现：</p>
<ul>
<li>把业务类变为EmpServiceB时，需要修改controller层中的代码</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428113525036.png" style="zoom:80%;" /> 

<p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p>
<img src="../images/SpringBootWeb请求响应/image-20220828215549593.png" style="zoom: 60%;" />





<h4 id="2-2-解耦思路"><a href="#2-2-解耦思路" class="headerlink" title="2.2  解耦思路"></a>2.2  解耦思路</h4><p>之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 <strong>这种做法呢，层与层之间代码就耦合了</strong>，当service层的实现变了之后， 我们还需要修改controller层的代码。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428113951754.png" alt="image-20240428113951754" style="zoom:80%;" />

<p> 那应该怎么解耦呢？</p>
<p>1 首先不能在EmpController中使用new对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="comment">// 业务层对象</span></span><br><span class="line">    <span class="keyword">private</span> IEmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Employee&gt; employees = employeeService.list();</span><br><span class="line">        <span class="comment">//2 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？</p>
<p>3 我们的解决思路是：</p>
<ul>
<li>提供一个容器，容器中存储一些对象(例：EmployeeServiceImplX对象)</li>
<li>controller程序从容器中获取 EmployeeServiceImplX 类型的对象</li>
</ul>
<p>我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：</p>
<ul>
<li><p><strong>控制反转：</strong> Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p>
<blockquote>
<p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器</p>
</blockquote>
</li>
<li><p><strong>依赖注入：</strong> Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p>
<blockquote>
<p>程序运行时需要某个资源，此时容器就为其提供这个资源。</p>
<p>例：EmployeeController程序运行时需要EmployeeServiceImplX 对象，Spring容器就为其提供并注入EmployeeServiceImplX 对象</p>
</blockquote>
</li>
</ul>
<p>IOC容器中创建、管理的对象，称之为：bean对象</p>
<h3 id="3、IOC-DI"><a href="#3、IOC-DI" class="headerlink" title="3、IOC&amp;DI"></a>3、IOC&amp;DI</h3><p>上面我们引出了Spring中IOC和DI的基本概念，下面我们就来具体学习下IOC和DI的代码实现。</p>
<h4 id="3-1-IOC-DI入门"><a href="#3-1-IOC-DI入门" class="headerlink" title="3.1 IOC&amp;DI入门"></a>3.1 IOC&amp;DI入门</h4><p>任务：完成Controller层、Service层、Dao层的代码解耦</p>
<ul>
<li>思路：<ol>
<li>删除Controller层、Service层中new对象的代码</li>
<li>Service层及Dao层的实现类，交给IOC容器管理</li>
<li>为Controller和Service注入运行时依赖的对象<ul>
<li>Controller程序中注入依赖的Service层对象</li>
<li>Service程序中注入依赖的Dao层对象</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>第1步：删除Controller层、Service层中new对象的代码</p>
<img src="../images/SpringBootWeb请求响应/image-20240428115709385.png" alt="image-20240428115709385" style="zoom:80%;" />



<p>第2步：Service层及Dao层的实现类，交给IOC容器管理</p>
<ul>
<li>使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理</li>
</ul>
<p>第3步：为Controller及Service注入运行时依赖的对象</p>
<ul>
<li>使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象</li>
</ul>
<p>完整的三层代码：</p>
<ul>
<li><strong>Controller层：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> IEmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Employee&gt; employees = employeeService.list();</span><br><span class="line">        <span class="comment">//2 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Service层：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">IEmployeeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> IEmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employees = employeeDao.selectAll();</span><br><span class="line">        employees.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">imageName</span> <span class="operator">=</span> emp.getImage();</span><br><span class="line">            emp.setImage(<span class="string">&quot;/imgs/&quot;</span> + imageName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Dao层：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDaoImplA</span> <span class="keyword">implements</span> <span class="title class_">IEmployeeDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emps.xml&quot;</span>).getFile();</span><br><span class="line">        List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class);</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试：</p>
<ul>
<li>启动SpringBoot引导类，打开浏览器，输入：<a target="_blank" rel="noopener" href="http://localhost:8080/emp.html">http://localhost:8080/emp.html</a></li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428120501857.png" alt="image-20240428120501857" style="zoom:80%;" />



<h4 id="3-2-IOC详解"><a href="#3-2-IOC详解" class="headerlink" title="3.2 IOC详解"></a>3.2 IOC详解</h4><p>通过IOC和DI的入门程序呢，我们已经基本了解了IOC和DI的基础操作。接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。</p>
<h5 id="3-3-2-1-bean的声明"><a href="#3-3-2-1-bean的声明" class="headerlink" title="3.3.2.1 bean的声明"></a>3.3.2.1 bean的声明</h5><p>前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p>
<p>在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component </p>
<p>而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p>
<ul>
<li>@Controller    （标注在控制层类上）</li>
<li>@Service          （标注在业务层类上）</li>
<li>@Repository    （标注在数据访问层类上）</li>
</ul>
<p>修改入门案例代码：</p>
<ul>
<li><strong>Controller层：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> IEmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Employee&gt; employees = employeeService.list();</span><br><span class="line">        <span class="comment">//2 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Service层：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeServiceImplA</span> <span class="keyword">implements</span> <span class="title class_">IEmployeeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IEmployeeDao employeeDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employees = employeeDao.selectAll();</span><br><span class="line">        employees.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">imageName</span> <span class="operator">=</span> emp.getImage();</span><br><span class="line">            emp.setImage(<span class="string">&quot;/imgs/&quot;</span> + imageName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Dao层：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDaoImplA</span> <span class="keyword">implements</span> <span class="title class_">IEmployeeDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emps.xml&quot;</span>).getFile();</span><br><span class="line">        List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class);</span><br><span class="line">        <span class="keyword">return</span> employees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th>说明</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Controller</td>
<td>@Component的衍生注解</td>
<td>标注在控制器类上</td>
</tr>
<tr>
<td align="left">@Service</td>
<td>@Component的衍生注解</td>
<td>标注在业务类上</td>
</tr>
<tr>
<td align="left">@Repository</td>
<td>@Component的衍生注解</td>
<td>标注在数据访问类上（由于与mybatis整合，用的少）</td>
</tr>
<tr>
<td align="left">@Component</td>
<td>声明bean的基础注解</td>
<td>不属于以上三类时，用此注解</td>
</tr>
</tbody></table>
<p>在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428121006476.png" alt="image-20240428121006476" style="zoom:80%;" /> 

<blockquote>
<p>注意事项: </p>
<ul>
<li>声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</li>
<li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</li>
</ul>
</blockquote>
<h5 id="3-3-2-2-组件扫描"><a href="#3-3-2-2-组件扫描" class="headerlink" title="3.3.2.2 组件扫描"></a>3.3.2.2 组件扫描</h5><p>问题：使用前面学习的四个注解声明的bean，一定会生效吗？</p>
<p>答案：不一定。（原因：bean想要生效，还需要被组件扫描）</p>
<p> 下面我们通过修改项目工程的目录结构，来测试bean对象是否生效：</p>
<img src="../images/SpringBootWeb请求响应/image-20240428124440724.png" alt="image-20240428124440724" style="zoom:80%;" /> 

<p>运行程序后，报错：</p>
<img src="../images/SpringBootWeb请求响应/image-20240428124657247.png" alt="image-20240428124657247" style="zoom:80%;" />

<p>为什么没有找到bean对象呢？</p>
<ul>
<li>使用四大注解声明的bean，要想生效，还需要被<strong>组件扫描注解@ComponentScan扫描</strong></li>
</ul>
<blockquote>
<p>@ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，&#x3D;&#x3D;<strong>默认扫描的范围是SpringBoot启动类所在包及其子包</strong>&#x3D;&#x3D;。</p>
<img src="../images/SpringBootWeb请求响应/image-20221204224643683.png" alt="image-20221204224643683" style="zoom:70%;" /> 
</blockquote>
<ul>
<li>解决方案：手动添加@ComponentScan注解，指定要扫描的包   （&#x3D;&#x3D;仅做了解，不推荐&#x3D;&#x3D;）</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428121526487.png" alt="image-20240428121526487" style="zoom:80%;" /> 



<p>推荐做法（如下图）：</p>
<ul>
<li>将我们定义的controller，service，dao这些包呢，都放在引导类所在包cn.wolfcode的子包下，这样我们定义的bean就会被自动的扫描到</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428125011918.png" alt="image-20240428125011918" style="zoom:80%;" /> 



<h4 id="3-3-DI详解"><a href="#3-3-DI详解" class="headerlink" title="3.3 DI详解"></a>3.3 DI详解</h4><p>上一小节我们讲解了控制反转IOC的细节，接下来呢，我们学习依赖注解DI的细节。</p>
<p>依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p>
<p>在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。</p>
<p>@Autowired注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p>
<blockquote>
<p>入门程序举例：在EmployeeController运行的时候，就要到IOC容器当中去查找 IEmployeeService 这个类型的对象，而我们的IOC容器中刚好有一个IEmployeeService 这个类型的对象，所以就找到了这个类型的对象完成注入操作。</p>
</blockquote>
<p>那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？</p>
<img src="../images/SpringBootWeb请求响应/image-20240428125456523.png" alt="image-20240428125456523" style="zoom:80%;" />

<ul>
<li>程序运行会报错</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428125626538.png" alt="image-20240428125626538" style="zoom:80%;" />

<p>如何解决上述问题呢？Spring提供了以下几种解决方案：</p>
<ul>
<li><p>@Primary</p>
</li>
<li><p>@Qualifier</p>
</li>
<li><p>@Resource</p>
</li>
</ul>
<p>使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428130115789.png" alt="image-20240428130115789" style="zoom:80%;" /> 

<p>使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。</p>
<ul>
<li>@Qualifier注解不能单独使用，必须配合@Autowired使用</li>
</ul>
<img src="../images/SpringBootWeb请求响应/image-20240428130342227.png" alt="image-20240428130342227" style="zoom:80%;" /> 

<p>使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p>
<img src="../images/SpringBootWeb请求响应/image-20240428130650909.png" alt="image-20240428130650909" style="zoom:80%;" /> 



<p>面试题 ： @Autowird 与 @Resource的区别</p>
<ul>
<li><p>@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解</p>
</li>
<li><p>@Autowired 默认是按照类型注入，而@Resource是按照名称注入</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-19T10:35:51.000Z" title="2024/6/19 18:35:51">2024-06-19</time>发表</span><span class="level-item"><time dateTime="2024-06-20T02:55:15.659Z" title="2024/6/20 10:55:15">2024-06-20</time>更新</span><span class="level-item">37 分钟读完 (大约5530个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/19/Maven/">Maven</a></p><div class="content"><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol>
<li>初识Maven</li>
<li>Maven概述<ul>
<li>Maven模型介绍</li>
<li>Maven仓库介绍</li>
<li>Maven安装与配置</li>
</ul>
</li>
<li>IDEA集成Maven</li>
<li>依赖管理</li>
</ol>
<h2 id="01-Maven课程介绍"><a href="#01-Maven课程介绍" class="headerlink" title="01. Maven课程介绍"></a>01. Maven课程介绍</h2><h3 id="1-1-课程安排"><a href="#1-1-课程安排" class="headerlink" title="1.1 课程安排"></a>1.1 课程安排</h3><p>学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，<strong>后端Web开发技术是我们学习的重点</strong>。</p>
<p><img src="/../images/Maven/image-20221130095316032.png" alt="image-20221130095316032"></p>
<p>后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven</p>
<h3 id="1-2-初识Maven"><a href="#1-2-初识Maven" class="headerlink" title="1.2 初识Maven"></a>1.2 初识Maven</h3><h4 id="1-2-1-什么是Maven"><a href="#1-2-1-什么是Maven" class="headerlink" title="1.2.1 什么是Maven"></a>1.2.1 什么是Maven</h4><p>Maven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://maven.apache.org/">https://maven.apache.org/</a></p>
<blockquote>
<p>Apache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。</p>
<p>开源项目：<a target="_blank" rel="noopener" href="https://www.apache.org/index.html#projects-list">https://www.apache.org/index.html#projects-list</a></p>
</blockquote>
<h4 id="1-2-2-Maven的作用"><a href="#1-2-2-Maven的作用" class="headerlink" title="1.2.2 Maven的作用"></a>1.2.2 Maven的作用</h4><p>使用Maven能够做什么呢？</p>
<ol>
<li>依赖管理</li>
<li>统一项目结构</li>
<li>项目构建</li>
</ol>
<p><strong>依赖管理</strong>：</p>
<ul>
<li>方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题</li>
</ul>
<p><img src="/../images/Maven/image-20221130104014162.png" alt="image-20221130104014162"></p>
<p>当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。</p>
<p><img src="/../images/Maven/image-20220616001159531.png" alt="image-20220616001159531">  </p>
<p>**统一项目结构 : **</p>
<ul>
<li>提供标准、统一的项目结构</li>
</ul>
<p>在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时：</p>
<p><img src="/../images/Maven/image-20221130212841973.png" alt="image-20221130212841973"> </p>
<p>若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：</p>
<p><img src="/../images/Maven/image-20221130220539444.png" alt="image-20221130220539444"></p>
<p>具体的统一结构如下：</p>
<img src="../images/Maven/image-20221130140132209.png" alt="image-20221130140132209" style="zoom:80%;" />

<blockquote>
<p>目录说明： </p>
<ul>
<li>src&#x2F;main&#x2F;java: java源代码目录</li>
<li>src&#x2F;main&#x2F;resources:  配置文件信息</li>
<li>src&#x2F;test&#x2F;java: 测试代码</li>
<li>src&#x2F;test&#x2F;resources: 测试配置文件信息</li>
</ul>
</blockquote>
<p><strong>项目构建 :</strong> </p>
<ul>
<li>maven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式</li>
</ul>
<img src="../images/Maven/image-20221130140247524.png" alt="image-20221130140247524" style="zoom:67%;" />

<p>如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p>
<p><img src="/../images/Maven/image-20221130222907628.png" alt="image-20221130222907628"></p>
<p>综上所述，可以得到一个结论：<strong>Maven是一款管理和构建java项目的工具</strong></p>
<h2 id="02-Maven概述"><a href="#02-Maven概述" class="headerlink" title="02. Maven概述"></a>02. Maven概述</h2><h3 id="2-1-Maven介绍"><a href="#2-1-Maven介绍" class="headerlink" title="2.1 Maven介绍"></a>2.1 Maven介绍</h3><p>Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://maven.apache.org/">https://maven.apache.org/</a></p>
<p>Maven的作用： </p>
<ol>
<li>方便的依赖管理</li>
<li>统一的项目结构</li>
<li>标准的项目构建流程</li>
</ol>
<h3 id="2-2-Maven模型"><a href="#2-2-Maven模型" class="headerlink" title="2.2 Maven模型"></a>2.2 Maven模型</h3><ul>
<li>项目对象模型 (Project Object Model)</li>
<li>依赖管理模型(Dependency)</li>
<li>构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)</li>
</ul>
<p>1). 构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)</p>
<p><img src="/../images/Maven/image-20221130142100703.png" alt="image-20221130142100703"></p>
<p>以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。 </p>
<p>2). 项目对象模型 (Project Object Model)</p>
<p><img src="/../images/Maven/image-20221130142643255.png" alt="image-20221130142643255"></p>
<p>以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：</p>
<p><img src="/../images/Maven/image-20220616094113852.png" alt="image-20220616094113852"></p>
<blockquote>
<p>坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置</p>
<p><img src="/../images/Maven/image-20221130230134757.png" alt="image-20221130230134757"></p>
</blockquote>
<p>3). 依赖管理模型(Dependency)</p>
<p><img src="/../images/Maven/image-20221130143139644.png" alt="image-20221130143139644"></p>
<p>以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包</p>
<p><img src="/../images/Maven/image-20221130174805973.png" alt="image-20221130174805973"></p>
<p>之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在书写在pom.xml文件中的坐标又是怎么能找到所要的jar包文件的呢？</p>
<blockquote>
<p>答案：Maven仓库</p>
</blockquote>
<h3 id="2-3-Maven仓库"><a href="#2-3-Maven仓库" class="headerlink" title="2.3 Maven仓库"></a>2.3 Maven仓库</h3><p>仓库：用于存储资源，管理各种jar包</p>
<blockquote>
<p>仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件</p>
</blockquote>
<p>Maven仓库分为：</p>
<ul>
<li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li>
<li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li>
<li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li>
</ul>
<p><img src="/../images/Maven/image-20220616095633552.png" alt="image-20220616095633552"></p>
<p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包</p>
<ul>
<li><p>如果有，则在项目直接引用</p>
</li>
<li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库</p>
</li>
</ul>
<p>如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库</p>
<h3 id="2-4-Maven安装"><a href="#2-4-Maven安装" class="headerlink" title="2.4 Maven安装"></a>2.4 Maven安装</h3><p>认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。</p>
<h4 id="2-4-1-下载"><a href="#2-4-1-下载" class="headerlink" title="2.4.1 下载"></a>2.4.1 下载</h4><p>下载地址：<a target="_blank" rel="noopener" href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p>在提供的资料中，已经提供了下载好的安装包。如下： </p>
<p><img src="/../images/Maven/image-20220616100211209.png" alt="image-20220616100211209"> </p>
<h4 id="2-4-2-安装步骤"><a href="#2-4-2-安装步骤" class="headerlink" title="2.4.2 安装步骤"></a>2.4.2 安装步骤</h4><p>Maven安装配置步骤：</p>
<ol>
<li>解压安装</li>
<li>配置仓库</li>
<li>配置Maven环境变量</li>
</ol>
<p><strong>1、解压 apache-maven-3.6.1-bin.zip（解压即安装）</strong></p>
<blockquote>
<p>建议解压到没有中文、特殊字符的路径下。如课程中解压到 <code>E:\develop</code> 下。</p>
</blockquote>
<p><img src="/../images/Maven/1-1669821012006.gif"> </p>
<p>解压缩后的目录结构如下：</p>
<p><img src="/../images/Maven/image-20220616100529868-1669794069698.png" alt="image-20220616100529868"> </p>
<ul>
<li>bin目录 ： 存放的是可执行命令。（mvn 命令重点关注）</li>
<li>conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改）</li>
<li>lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包）</li>
</ul>
<p><strong>2、配置本地仓库</strong></p>
<p>2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包）</p>
<p><img src="/../images/Maven/image-20221130231857537.png" alt="image-20221130231857537"> </p>
<p>2.2、进入到conf目录下修改settings.xml配置文件 </p>
<p>1). 使用超级记事本软件，打开settings.xml文件，定位到53行</p>
<p>2). 复制<localRepository>标签，粘贴到注释的外面（55行）</p>
<p>3). 复制之前新建的用来存储jar包的路径，替换掉<localRepository>标签体内容</p>
<img src="../images/Maven/2.gif" style="zoom:80%;" />



<p><strong>3、配置阿里云私服</strong></p>
<p>由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p>
<p>进入到conf目录下修改settings.xml配置文件：</p>
<p>1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右</p>
<p>2). 在<mirrors>标签下为其添加子标签<mirror>，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/Maven/3.gif"></p>
<p>注意配置的位置，在<mirrors> … </mirrors> 中间添加配置。如下图所示：</p>
<p><img src="/../images/Maven/image-20221130161346565.png" alt="image-20221130161346565"></p>
<p>&#x3D;&#x3D;注:  只可配置一个<mirror>(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!&#x3D;&#x3D;</p>
<p><strong>4、配置环境变量</strong></p>
<blockquote>
<p>Maven环境变量的配置类似于JDK环境变量配置一样</p>
</blockquote>
<p>1). 在系统变量处新建一个变量MAVEN_HOME</p>
<ul>
<li>MAVEN_HOME环境变量的值，设置为maven的解压安装目录</li>
</ul>
<img src="../images/Maven/image-20220616102344350.png" style="zoom:80%;" />



<p>2). 在Path中进行配置</p>
<ul>
<li>PATH环境变量的值，设置为：%MAVEN_HOME%\bin</li>
</ul>
<img src="../images/Maven/image-20220616102435856.png" style="zoom:80%;" /> 



<p>3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Maven/image-20220616102554143.png" alt="image-20220616102554143"> </p>
<h2 id="03-IDEA集成Maven"><a href="#03-IDEA集成Maven" class="headerlink" title="03. IDEA集成Maven"></a>03. IDEA集成Maven</h2><p>我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven</p>
<h3 id="3-1-配置Maven环境"><a href="#3-1-配置Maven环境" class="headerlink" title="3.1 配置Maven环境"></a>3.1 配置Maven环境</h3><h4 id="3-1-1-当前工程设置"><a href="#3-1-1-当前工程设置" class="headerlink" title="3.1.1 当前工程设置"></a>3.1.1 当前工程设置</h4><p>1、选择 IDEA中 File  &#x3D;&gt;  Settings  &#x3D;&gt;  Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven</p>
<p><img src="/../images/Maven/image-20220616103219646.png" alt="image-20220616103219646"> </p>
<p><img src="/../images/Maven/image-20221130234731629.png" alt="image-20221130234731629"></p>
<p>2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径</p>
<p><img src="/../images/Maven/image-20220616103302386.png"></p>
<blockquote>
<p>Maven home path ：指定当前Maven的安装目录</p>
<p>User settings file ：指定当前Maven的settings.xml配置文件的存放路径</p>
<p>Local repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定)</p>
</blockquote>
<p>3、配置工程的编译版本为11</p>
<ul>
<li>Maven默认使用的编译版本为5（版本过低）</li>
</ul>
<p><img src="/../images/Maven/image-20221201093737128.png" alt="image-20221201093737128"> </p>
<p>上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。</p>
<h4 id="3-1-2-全局设置"><a href="#3-1-2-全局设置" class="headerlink" title="3.1.2 全局设置"></a>3.1.2 全局设置</h4><p>1、进入到IDEA欢迎页面</p>
<ul>
<li>选择 IDEA中 File  &#x3D;&gt;  close project</li>
</ul>
<img src="../images/Maven/4.gif" style="zoom:80%;" />

<img src="../images/Maven/image-20220616104338612.png" style="zoom:80%;" />



<p>2、打开 All settings , 选择 Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven</p>
<img src="../images/Maven/image-20220616104517726.png" style="zoom:80%;" />



<p>3、配置工程的编译版本为11</p>
<img src="../images/Maven/image-20221201093737128.png" alt="image-20221201093737128" style="zoom:80%;" />

<p>这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。</p>
<h3 id="3-2-Maven项目"><a href="#3-2-Maven项目" class="headerlink" title="3.2 Maven项目"></a>3.2 Maven项目</h3><h4 id="3-2-1-创建Maven项目"><a href="#3-2-1-创建Maven项目" class="headerlink" title="3.2.1 创建Maven项目"></a>3.2.1 创建Maven项目</h4><p>1、创建一个空项目 </p>
<img src="../images/Maven/image-20221201095621738.png" alt="image-20221201095621738" style="zoom:80%;" />

<img src="../images/Maven/image-20221201095600057.png" alt="image-20221201095600057" style="zoom:80%;" />



<p>2、创建模块，选择Maven，点击Next</p>
<img src="../images/Maven/image-20221201095831320.png" alt="image-20221201095831320" style="zoom:80%;" />

<img src="../images/Maven/image-20221201100011799.png" alt="image-20221201100011799" style="zoom:80%;" />



<p>3、填写模块名称，坐标信息，点击finish，创建完成</p>
<img src="../images/Maven/image-20221201100502234.png" alt="image-20221201100502234" style="zoom:80%;" /> 



<p>4、在Maven工程下，创建HelloWorld类</p>
<img src="../images/Maven/image-20221201101603397.png" alt="image-20221201101603397" style="zoom:80%;" />

<img src="../images/Maven/image-20221201101643427.png" alt="image-20221201101643427" style="zoom:80%;" />

<blockquote>
<ul>
<li><p>Maven项目的目录结构:</p>
<p>maven-project01<br>|—  src  (源代码目录和测试代码目录)<br>        |—  main (源代码目录)<br>                   |— java (源代码java文件目录)<br>                   |— resources (源代码配置文件目录)<br>        |—  test (测试代码目录)<br>                   |— java (测试代码java目录)<br>                   |— resources (测试代码配置文件目录)<br>|— target (编译、打包生成文件存放目录)</p>
</li>
</ul>
</blockquote>
<p>5、编写 HelloWorld，并运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Maven ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-2-POM配置详解"><a href="#3-2-2-POM配置详解" class="headerlink" title="3.2.2 POM配置详解"></a>3.2.2 POM配置详解</h4><p>POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。</p>
<ul>
<li>使用pom.xml文件来实现</li>
</ul>
<p>pom.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- POM模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 打包方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>pom文件详解：</p>
<ul>
<li><project> ：pom文件的根标签，表示当前maven项目</li>
<li><modelVersion> ：声明项目描述遵循哪一个POM模型版本<ul>
<li>虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0</li>
</ul>
</li>
<li>坐标 ：<groupId>、<artifactId>、<version><ul>
<li>定位项目在本地仓库中的位置，由以上三个标签组成一个坐标</li>
</ul>
</li>
<li><packaging> ：maven项目的打包方式，通常设置为jar或war（默认值：jar）</li>
</ul>
<h4 id="3-2-3-Maven坐标详解"><a href="#3-2-3-Maven坐标详解" class="headerlink" title="3.2.3 Maven坐标详解"></a>3.2.3 Maven坐标详解</h4><p>什么是坐标？</p>
<ul>
<li>Maven中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D; , 通过该坐标可以唯一定位资源位置</li>
<li>使用坐标来定义项目或引入项目中需要的依赖</li>
</ul>
<p>Maven坐标主要组成</p>
<ul>
<li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li>
<li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li>
<li>version：定义当前项目版本号</li>
</ul>
<p>如下图就是使用坐标表示一个项目：</p>
<p><img src="/../images/Maven/image-20220616111031057.png" alt="image-20220616111031057"> </p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>上面所说的资源可以是插件、依赖、当前项目。</li>
<li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li>
</ul>
</blockquote>
<h3 id="3-3-导入Maven项目"><a href="#3-3-导入Maven项目" class="headerlink" title="3.3 导入Maven项目"></a>3.3 导入Maven项目</h3><ul>
<li><strong>方式1：使用Maven面板，快速导入项目</strong></li>
</ul>
<p>打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可</p>
<p><img src="/../images/Maven/image-20221201104320521.png" alt="image-20221201104320521"></p>
<img src="../images/Maven/image-20221201104906754.png" alt="image-20221201104906754" style="zoom:80%;" /> 

<blockquote>
<p>说明：如果没有Maven面板，选择 View  &#x3D;&gt;  Appearance  &#x3D;&gt;  Tool Window Bars</p>
<p><img src="/../images/Maven/image-20220616111937679.png" alt="image-20220616111937679"> </p>
</blockquote>
<ul>
<li><strong>方式2：使用idea导入模块项目</strong></li>
</ul>
<p>File  &#x3D;&gt;  Project Structure  &#x3D;&gt;  Modules  &#x3D;&gt;  +  &#x3D;&gt;  Import Module</p>
<img src="../images/Maven/image-20220823161727718.png" style="zoom:80%;" />

<p>找到要导入工程的pom.xml</p>
<p><img src="/../images/Maven/image-20221201105532909.png" alt="image-20221201105532909"></p>
<img src="../images/Maven/image-20221201105845872.png" alt="image-20221201105845872" style="zoom:80%;" />







<h2 id="04-依赖管理"><a href="#04-依赖管理" class="headerlink" title="04. 依赖管理"></a>04. 依赖管理</h2><h3 id="4-1-依赖配置"><a href="#4-1-依赖配置" class="headerlink" title="4.1 依赖配置"></a>4.1 依赖配置</h3><p>依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：</p>
<p>例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：</p>
<ol>
<li><p>在pom.xml中编写<dependencies>标签</p>
</li>
<li><p>在<dependencies>标签中使用<dependency>引入坐标</p>
</li>
<li><p>定义坐标的 groupId、artifactId、version</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第1个依赖 : logback --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第2个依赖 : junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>点击刷新按钮，引入最新加入的坐标<ul>
<li>刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标</li>
</ul>
</li>
</ol>
<p><img src="/../images/Maven/image-20221130184402805.png" alt="image-20221130184402805">  </p>
<blockquote>
<p>注意事项：</p>
<ol>
<li>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 &#x2F; 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）</li>
<li>如果不知道依赖的坐标信息，可以到mvn的中央仓库（<a target="_blank" rel="noopener" href="https://mvnrepository.com/%EF%BC%89%E4%B8%AD%E6%90%9C%E7%B4%A2">https://mvnrepository.com/）中搜索</a></li>
</ol>
</blockquote>
<p><strong>添加依赖的几种方式：</strong></p>
<ol>
<li><p>利用中央仓库搜索的依赖坐标</p>
<img src="../images/Maven/5.gif" style="zoom:80%;" />


</li>
<li><p>利用IDEA工具搜索依赖</p>
<img src="../images/Maven/6.gif" style="zoom:80%;" />


</li>
<li><p>熟练上手maven后，快速导入依赖</p>
<img src="../images/Maven/7.gif" style="zoom:80%;" /></li>
</ol>
<h3 id="4-2-依赖传递"><a href="#4-2-依赖传递" class="headerlink" title="4.2 依赖传递"></a>4.2 依赖传递</h3><h4 id="4-2-1-依赖具有传递性"><a href="#4-2-1-依赖具有传递性" class="headerlink" title="4.2.1 依赖具有传递性"></a>4.2.1 依赖具有传递性</h4><p>早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下</p>
<p><img src="/../images/Maven/image-20221201120514644.png" alt="image-20221201120514644"></p>
<p>我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。</p>
<p><img src="/../images/Maven/image-20221201113659400.png" alt="image-20221201113659400"></p>
<p>在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。</p>
<p>依赖传递可以分为：</p>
<ol>
<li><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系</p>
</li>
<li><p>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p>
</li>
</ol>
<p><img src="/../images/Maven/image-20220616115445812.png" alt="image-20220616115445812"> </p>
<p>比如以上图中：</p>
<ul>
<li>projectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。</li>
<li>而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。</li>
</ul>
<p><img src="/../images/Maven/image-20221201115801806.png" alt="image-20221201115801806"></p>
<h4 id="4-2-2-排除依赖"><a href="#4-2-2-排除依赖" class="headerlink" title="4.2.2 排除依赖"></a>4.2.2 排除依赖</h4><p>问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？ </p>
<p>答案：在maven项目中，我们可以通过排除依赖来实现。</p>
<p>什么是排除依赖？</p>
<ul>
<li>排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-projectB<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--排除依赖, 主动断开依赖的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>依赖排除示例：</p>
<ul>
<li>maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit</li>
</ul>
<p><img src="/../images/Maven/image-20221201141929240.png" alt="image-20221201141929240"></p>
<ul>
<li>使用排除依赖后</li>
</ul>
<p><img src="/../images/Maven/image-20221201142501556.png" alt="image-20221201142501556"></p>
<h3 id="4-3-依赖范围"><a href="#4-3-依赖范围" class="headerlink" title="4.3 依赖范围"></a>4.3 依赖范围</h3><p>在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。</p>
<p><img src="/../images/Maven/image-20221201135142706.png" alt="image-20221201135142706"></p>
<p>如果希望限制依赖的使用范围，可以通过<scope>标签设置其作用范围。</p>
<p><img src="/../images/Maven/image-20220616123806894.png" alt="image-20220616123806894"> </p>
<p>作用范围：</p>
<ol>
<li><p>主程序范围有效（main文件夹范围内）</p>
</li>
<li><p>测试程序范围有效（test文件夹范围内）</p>
</li>
<li><p>是否参与打包运行（package指令范围内）</p>
</li>
</ol>
<p><img src="/../images/Maven/image-20221201140140947.png" alt="image-20221201140140947"></p>
<p>如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p>
<p>scope标签的取值范围：</p>
<table>
<thead>
<tr>
<th><strong>scope</strong>值</th>
<th><strong>主程序</strong></th>
<th><strong>测试程序</strong></th>
<th><strong>打包（运行）</strong></th>
<th><strong>范例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>compile（默认）</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>log4j</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>jdbc驱动</td>
</tr>
</tbody></table>
<h3 id="4-4-生命周期"><a href="#4-4-生命周期" class="headerlink" title="4.4 生命周期"></a>4.4 生命周期</h3><h4 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h4><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。</p>
<p>在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。</p>
<p>Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。</p>
<p>Maven对项目构建的生命周期划分为3套（相互独立）：</p>
<p><img src="/../images/Maven/image-20220616124015567.png"></p>
<ul>
<li><p>clean：清理工作。</p>
</li>
<li><p>default：核心工作。如：编译、测试、打包、安装、部署等。</p>
</li>
<li><p>site：生成报告、发布站点等。</p>
</li>
</ul>
<p>三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图:</p>
<p><img src="/../images/Maven/image-20220616124348972.png" alt="image-20220616124348972"> </p>
<p>我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：</p>
<p>• clean：移除上一次构建生成的文件</p>
<p>• compile：编译项目源代码</p>
<p>• test：使用合适的单元测试框架运行测试(junit)</p>
<p>• package：将编译后的文件打包，如：jar、war等</p>
<p>• install：安装项目到本地仓库</p>
<p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong></p>
<p><img src="/../images/Maven/image-20221130142100703.png" alt="image-20221130142100703"></p>
<p>IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道</p>
<p><img src="/../images/Maven/image-20221201151340340.png" alt="image-20221201151340340"></p>
<p>生命周期的顺序是：clean –&gt; validate –&gt; compile –&gt; test –&gt; package –&gt; verify –&gt; install –&gt; site –&gt; deploy </p>
<p>我们需要关注的就是：clean –&gt;  compile –&gt; test –&gt; package  –&gt; install </p>
<blockquote>
<p>说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。</p>
</blockquote>
<blockquote>
<p> 思考：当运行package生命周期时，clean、compile生命周期会不会运行？</p>
<p> ​		clean不会运行，compile会运行。  因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。</p>
</blockquote>
<h4 id="4-4-2-执行"><a href="#4-4-2-执行" class="headerlink" title="4.4.2 执行"></a>4.4.2 执行</h4><p>在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：</p>
<ol>
<li>在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行</li>
<li>在DOS命令行中，通过maven命令执行</li>
</ol>
<p><strong>方式一：在idea中执行生命周期</strong></p>
<ul>
<li>选择对应的生命周期，双击执行</li>
</ul>
<p><img src="/../images/Maven/image-20221201161957301.png" alt="image-20221201161957301"> </p>
<p>compile：</p>
<p><img src="/../images/Maven/image-20221201163711835.png" alt="image-20221201163711835"></p>
<p>test：</p>
<p><img src="/../images/Maven/image-20221201164627403.png" alt="image-20221201164627403"></p>
<p>package：</p>
<p><img src="/../images/Maven/image-20221201165801341.png" alt="image-20221201165801341"></p>
<p>install：</p>
<p><img src="/../images/Maven/image-20221201170830837.png" alt="image-20221201170830837"></p>
<p>clean：</p>
<p><img src="/../images/Maven/image-20221201171529382.png" alt="image-20221201171529382"></p>
<p><strong>方式二：在命令行中执行生命周期</strong></p>
<ol>
<li>进入到DOS命令行</li>
</ol>
<p><img src="/../images/Maven/image-20221201172210253.png" alt="image-20221201172210253"></p>
<p><img src="/../images/Maven/image-20221201172914648.png" alt="image-20221201172914648"> </p>
<h2 id="05-附录"><a href="#05-附录" class="headerlink" title="05. 附录"></a>05. 附录</h2><h3 id="5-1-更新依赖索引"><a href="#5-1-更新依赖索引" class="headerlink" title="5.1 更新依赖索引"></a>5.1 更新依赖索引</h3><p>有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：</p>
<p> 打开设置—-搜索maven—-Repositories—-选中本地仓库—–点击Update</p>
<p><img src="/../images/Maven/1537786634456-1582625518984.png" alt="1537786634456"></p>
<h3 id="5-2-清理maven仓库"><a href="#5-2-清理maven仓库" class="headerlink" title="5.2 清理maven仓库"></a>5.2 清理maven仓库</h3><p>初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。</p>
<p><img src="/../images/Maven/lastUpdated-1582625518983.png" alt="lastUpdate"></p>
<p>如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set REPOSITORY_PATH=E:\develop\apache-maven-3.6.1\mvn_repo</span><br><span class="line">rem 正在搜索...</span><br><span class="line"></span><br><span class="line">del /s /q %REPOSITORY_PATH%\*.lastUpdated</span><br><span class="line"></span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>



<p>操作步骤如下：</p>
<p>1). 定义批处理文件del_lastUpdated.bat  (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 )</p>
<p><img src="/../images/Maven/image-20221214154949482.png" alt="image-20221214154949482"> </p>
<p>2). 在上面的bat文件上<strong>右键—》编辑</strong> 。修改文件：</p>
<p><img src="/../images/Maven/image-20221214154559817.png" alt="image-20221214154559817"> </p>
<p>修改完毕后，双击运行即可删除maven仓库中的残留文件。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-06-18T12:51:53.744Z" title="2024/6/18 20:51:53">2024-06-18</time>发表</span><span class="level-item"><time dateTime="2025-06-13T03:59:14.468Z" title="2025/6/13 11:59:14">2025-06-13</time>更新</span><span class="level-item">2 分钟读完 (大约292个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/06/18/README/">README</a></p><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="基本操作说明"><a href="#基本操作说明" class="headerlink" title="基本操作说明"></a>基本操作说明</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="运行本地服务"><a href="#运行本地服务" class="headerlink" title="运行本地服务"></a>运行本地服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="清除已生成文件和缓存"><a href="#清除已生成文件和缓存" class="headerlink" title="清除已生成文件和缓存"></a>清除已生成文件和缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Clean</a></p>
<h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到远端站点"><a href="#部署到远端站点" class="headerlink" title="部署到远端站点"></a>部署到远端站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="控制台指令列表"><a href="#控制台指令列表" class="headerlink" title="控制台指令列表"></a>控制台指令列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Usage: hexo &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  clean     Remove generated files and cache.</span><br><span class="line">  config    Get or <span class="built_in">set</span> configurations.</span><br><span class="line">  deploy    Deploy your website.</span><br><span class="line">  generate  Generate static files.</span><br><span class="line">  <span class="built_in">help</span>      Get <span class="built_in">help</span> on a <span class="built_in">command</span>.</span><br><span class="line">  init      Create a new Hexo folder.</span><br><span class="line">  list      List the information of the site</span><br><span class="line">  migrate   Migrate your site from other system to Hexo.</span><br><span class="line">  new       Create a new post.</span><br><span class="line">  publish   Moves a draft post from _drafts to _posts folder.</span><br><span class="line">  render    Render files with renderer plugins.</span><br><span class="line">  server    Start the server.</span><br><span class="line">  version   Display version information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  --config  Specify config file instead of using _config.yml</span><br><span class="line">  --cwd     Specify the CWD</span><br><span class="line">  --debug   Display all verbose messages <span class="keyword">in</span> the terminal</span><br><span class="line">  --draft   Display draft posts</span><br><span class="line">  --safe    Disable all plugins and scripts</span><br><span class="line">  --silent  Hide output on console</span><br></pre></td></tr></table></figure>

</div></article></div></div><style>.column.column-left,.column.column-right{display:none}</style><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Hitori"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hitori</p><p class="is-size-6 is-block">Hitori之家</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenyang, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener" id="widget-follow">哔哩哔哩 Bilibili</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div><a class="link-more button is-light is-small size-small" href="/friends/">查看更多</a></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-07-04T02:42:00.000Z">2025-07-04</time></p><p class="title"><a href="/2025/07/04/Spring%20AI%20Alibaba%E6%80%BB%E7%BB%93/">Spring AI Alibaba总结</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-20T02:42:00.000Z">2024-06-20</time></p><p class="title"><a href="/2024/06/20/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/">SpringBootWeb请求响应</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-19T10:35:51.000Z">2024-06-19</time></p><p class="title"><a href="/2024/06/19/Maven/">Maven</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-06-18T12:51:53.744Z">2024-06-18</time></p><p class="title"><a href="/2024/06/18/README/">README</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/07/"><span class="level-start"><span class="level-item">七月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" id="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" id="twikoo-new"><div class="card-content"><div class="menu"><h3 class="menu-label">最新评论</h3><script>window.twikooEnvId = '';</script><div class="twikoo-new-container"></div></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><!--!--><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/logo.svg" alt="Hitori的博客" height="28"><img class="logo-img-dark" src="/img/logo.svg" alt="Hitori的博客" height="28"></a><p class="is-size-7"><span>&copy; 2025 Hitori</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用 Cookie，以启用评论系统和分析功能。",
          dismiss: "知道了",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>