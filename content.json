{"posts":[{"title":"README","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 基本操作说明快速开始创建一篇新文章1$ hexo new &quot;文章标题&quot; More info: Writing 运行本地服务1$ hexo server More info: Server 清除已生成文件和缓存1$ hexo clean More info: Clean 生成静态页面1$ hexo generate More info: Generating 部署到远端站点1$ hexo deploy More info: Deployment 控制台指令列表123456789101112131415161718192021222324Usage: hexo &lt;command&gt;Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on console","link":"/2024/06/18/README/"},{"title":"Maven","text":"课程内容 初识Maven Maven概述 Maven模型介绍 Maven仓库介绍 Maven安装与配置 IDEA集成Maven 依赖管理 01. Maven课程介绍1.1 课程安排学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，后端Web开发技术是我们学习的重点。 后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven 1.2 初识Maven1.2.1 什么是MavenMaven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。 官网：https://maven.apache.org/ Apache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。 开源项目：https://www.apache.org/index.html#projects-list 1.2.2 Maven的作用使用Maven能够做什么呢？ 依赖管理 统一项目结构 项目构建 依赖管理： 方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题 当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。 **统一项目结构 : ** 提供标准、统一的项目结构 在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时： 若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构： 具体的统一结构如下： 目录说明： src/main/java: java源代码目录 src/main/resources: 配置文件信息 src/test/java: 测试代码 src/test/resources: 测试配置文件信息 项目构建 : maven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 综上所述，可以得到一个结论：Maven是一款管理和构建java项目的工具 02. Maven概述2.1 Maven介绍Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。 官网：https://maven.apache.org/ Maven的作用： 方便的依赖管理 统一的项目结构 标准的项目构建流程 2.2 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 构建生命周期/阶段(Build lifecycle &amp; phases) 1). 构建生命周期/阶段(Build lifecycle &amp; phases) 以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。 2). 项目对象模型 (Project Object Model) 以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目： 坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置 3). 依赖管理模型(Dependency) 以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包 之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在书写在pom.xml文件中的坐标又是怎么能找到所要的jar包文件的呢？ 答案：Maven仓库 2.3 Maven仓库仓库：用于存储资源，管理各种jar包 仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件 Maven仓库分为： 本地仓库：自己计算机上的一个目录(用来存储jar包) 中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包 如果有，则在项目直接引用 如果没有，则去中央仓库中下载对应的jar包到本地仓库 如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库 2.4 Maven安装认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。 2.4.1 下载下载地址：https://maven.apache.org/download.cgi 在提供的资料中，已经提供了下载好的安装包。如下： 2.4.2 安装步骤Maven安装配置步骤： 解压安装 配置仓库 配置Maven环境变量 1、解压 apache-maven-3.6.1-bin.zip（解压即安装） 建议解压到没有中文、特殊字符的路径下。如课程中解压到 E:\\develop 下。 解压缩后的目录结构如下： bin目录 ： 存放的是可执行命令。（mvn 命令重点关注） conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改） lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包） 2、配置本地仓库 2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包） 2.2、进入到conf目录下修改settings.xml配置文件 1). 使用超级记事本软件，打开settings.xml文件，定位到53行 2). 复制标签，粘贴到注释的外面（55行） 3). 复制之前新建的用来存储jar包的路径，替换掉标签体内容 3、配置阿里云私服 由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 进入到conf目录下修改settings.xml配置文件： 1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右 2). 在标签下为其添加子标签，内容如下： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 注意配置的位置，在 … 中间添加配置。如下图所示： ==注: 只可配置一个(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!== 4、配置环境变量 Maven环境变量的配置类似于JDK环境变量配置一样 1). 在系统变量处新建一个变量MAVEN_HOME MAVEN_HOME环境变量的值，设置为maven的解压安装目录 2). 在Path中进行配置 PATH环境变量的值，设置为：%MAVEN_HOME%\\bin 3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功 1mvn -v 03. IDEA集成Maven我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven 3.1 配置Maven环境3.1.1 当前工程设置1、选择 IDEA中 File =&gt; Settings =&gt; Build,Execution,Deployment =&gt; Build Tools =&gt; Maven 2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径 Maven home path ：指定当前Maven的安装目录 User settings file ：指定当前Maven的settings.xml配置文件的存放路径 Local repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定) 3、配置工程的编译版本为11 Maven默认使用的编译版本为5（版本过低） 上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。 3.1.2 全局设置1、进入到IDEA欢迎页面 选择 IDEA中 File =&gt; close project 2、打开 All settings , 选择 Build,Execution,Deployment =&gt; Build Tools =&gt; Maven 3、配置工程的编译版本为11 这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。 3.2 Maven项目3.2.1 创建Maven项目1、创建一个空项目 2、创建模块，选择Maven，点击Next 3、填写模块名称，坐标信息，点击finish，创建完成 4、在Maven工程下，创建HelloWorld类 Maven项目的目录结构: maven-project01|— src (源代码目录和测试代码目录) |— main (源代码目录) |— java (源代码java文件目录) |— resources (源代码配置文件目录) |— test (测试代码目录) |— java (测试代码java目录) |— resources (测试代码配置文件目录)|— target (编译、打包生成文件存放目录) 5、编写 HelloWorld，并运行 12345public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello Maven ...&quot;); }} 3.2.2 POM配置详解POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。 使用pom.xml文件来实现 pom.xml文件： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- POM模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 当前项目坐标 --&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_project1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; pom文件详解： ：pom文件的根标签，表示当前maven项目 ：声明项目描述遵循哪一个POM模型版本 虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0 坐标 ：、、 定位项目在本地仓库中的位置，由以上三个标签组成一个坐标 ：maven项目的打包方式，通常设置为jar或war（默认值：jar） 3.2.3 Maven坐标详解什么是坐标？ Maven中的坐标是==资源的唯一标识== , 通过该坐标可以唯一定位资源位置 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目： 注意： 上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 3.3 导入Maven项目 方式1：使用Maven面板，快速导入项目 打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可 说明：如果没有Maven面板，选择 View =&gt; Appearance =&gt; Tool Window Bars 方式2：使用idea导入模块项目 File =&gt; Project Structure =&gt; Modules =&gt; + =&gt; Import Module 找到要导入工程的pom.xml 04. 依赖管理4.1 依赖配置依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖： 例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下： 在pom.xml中编写标签 在标签中使用引入坐标 定义坐标的 groupId、artifactId、version 1234567891011121314&lt;dependencies&gt; &lt;!-- 第1个依赖 : logback --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 第2个依赖 : junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 点击刷新按钮，引入最新加入的坐标 刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标 注意事项： 如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待） 如果不知道依赖的坐标信息，可以到mvn的中央仓库（https://mvnrepository.com/）中搜索 添加依赖的几种方式： 利用中央仓库搜索的依赖坐标 利用IDEA工具搜索依赖 熟练上手maven后，快速导入依赖 4.2 依赖传递4.2.1 依赖具有传递性早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下 我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。 在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。 依赖传递可以分为： 直接依赖：在当前项目中通过依赖配置建立的依赖关系 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 比如以上图中： projectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。 而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。 4.2.2 排除依赖问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？ 答案：在maven项目中，我们可以通过排除依赖来实现。 什么是排除依赖？ 排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本） 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven-projectB&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除依赖, 主动断开依赖的资源--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 依赖排除示例： maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit 使用排除依赖后 4.3 依赖范围在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。 如果希望限制依赖的使用范围，可以通过标签设置其作用范围。 作用范围： 主程序范围有效（main文件夹范围内） 测试程序范围有效（test文件夹范围内） 是否参与打包运行（package指令范围内） 如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 scope标签的取值范围： scope值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 4.4 生命周期4.4.1 介绍Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。 在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。 Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。 Maven对项目构建的生命周期划分为3套（相互独立）： clean：清理工作。 default：核心工作。如：编译、测试、打包、安装、部署等。 site：生成报告、发布站点等。 三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图: 我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个： • clean：移除上一次构建生成的文件 • compile：编译项目源代码 • test：使用合适的单元测试框架运行测试(junit) • package：将编译后的文件打包，如：jar、war等 • install：安装项目到本地仓库 Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。 IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道 生命周期的顺序是：clean –&gt; validate –&gt; compile –&gt; test –&gt; package –&gt; verify –&gt; install –&gt; site –&gt; deploy 我们需要关注的就是：clean –&gt; compile –&gt; test –&gt; package –&gt; install 说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。 思考：当运行package生命周期时，clean、compile生命周期会不会运行？ ​ clean不会运行，compile会运行。 因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。 4.4.2 执行在日常开发中，当我们要执行指定的生命周期时，有两种执行方式： 在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行 在DOS命令行中，通过maven命令执行 方式一：在idea中执行生命周期 选择对应的生命周期，双击执行 compile： test： package： install： clean： 方式二：在命令行中执行生命周期 进入到DOS命令行 05. 附录5.1 更新依赖索引有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下： 打开设置—-搜索maven—-Repositories—-选中本地仓库—–点击Update 5.2 清理maven仓库初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。 如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除： 1234567set REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_reporem 正在搜索...del /s /q %REPOSITORY_PATH%\\*.lastUpdatedrem 搜索完毕pause 操作步骤如下： 1). 定义批处理文件del_lastUpdated.bat (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 ) 2). 在上面的bat文件上右键—》编辑 。修改文件： 修改完毕后，双击运行即可删除maven仓库中的残留文件。","link":"/2024/06/19/Maven/"},{"title":"SpringBootWeb请求响应","text":"请求Request 必须掌握各种请求参数的映射规则 响应Response 了解后台响应前端的形式：Jsp和JSON 必须掌握JSON响应方式 掌握前后端分离统一响应的处理方式 请求响应综合应用 必须掌握雇员列表展示综合应用 分层架构 必须掌握分层架构思想 知道解耦思想 必须掌握IoC和DI 前言在上一次的课程中，我们开发了springbootweb的入门程序。 基于SpringBoot的方式开发一个web应用，浏览器发起请求 /hello 后 ，给浏览器返回字符串 “Hello World ~”。 其实呢，是我们在浏览器发起请求，请求了我们的后端web服务器(也就是内置的Tomcat)。而我们在开发web程序时呢，定义了一个控制器类Controller，请求会被部署在Tomcat中的Controller接收，然后Controller再给浏览器一个响应，响应一个字符串 “Hello World”。 而在请求响应的过程中是遵循HTTP协议的。 但是呢，这里要告诉大家的时，其实在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别 Servlet程序的。 那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？ 其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据。 那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后呢将解析后的请求数据会传递给Servlet程序的HttpServletRequest对象，那也就意味着 HttpServletRequest 对象就可以获取到请求数据。 而Tomcat，还给Servlet程序传递了一个参数 HttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。 123456789@WebServlet(&quot;/hello&quot;) public HelloServlet extends HttpServlet { public void service(HttpServletRequest request, HttpServletResponse response ) { // 接受浏览器请求 // 业务 // 向浏览器响应数据 }} 那上述所描述的这种浏览器/服务器的架构模式呢，我们称之为：BS架构。 • BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。 那今天呢，我们的课程内容主要就围绕着：请求、响应进行。 今天课程内容，主要包含三个部分： 请求 响应 分层解耦 一、请求 Request在本章节呢，我们主要讲解，如何接收页面传递过来的请求数据。 之前我们课程中有提到当前最为主流的开发模式：前后端分离 在这种模式下，前端技术人员基于”接口文档”，开发前端程序；后端技术人员也基于”接口文档”，开发后端程序。 由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？ 方式1：像之前SpringBoot入门案例中一样，直接使用浏览器。在浏览器中输入地址，测试后端程序。 弊端：在浏览器地址栏中输入地址这种方式都是GET请求，如何我们要用到POST请求怎么办呢？ 要解决POST请求，需要程序员自己编写前端代码（比较麻烦） 方式2：使用专业的接口测试工具（课程中我们使用Postman工具） 1、简单参数简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。 那么在后端程序中，如何接收传递过来的普通参数数据呢？ 我们在这里讲解两种方式： 原始方式 SpringBoot方式 1.1 原始方式 ( 了解 )在原始的Web程序当中，需要通过Servlet中提供的API——HttpServletRequest（请求对象）来获取请求的相关信息，比如获取请求参数。Tomcat接收到http请求时，把请求的相关信息封装到HttpServletRequest对象中 在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明 HttpServletRequest 对象。然后就可以通过该对象来获取请求信息： HttpServletRequest 常用方法 功能 String getParameter( 参数名 ) 从请求对象HttpServletRequest中获取请求参数的数据值 123456789101112131415161718@RestControllerpublic class RequestController { //原始方式 @RequestMapping(&quot;/simple&quot;) public String simpleParam(HttpServletRequest request){ // http://localhost:8080/simple?name=will&amp;age=10 // 请求参数： name=will&amp;age=17 （有2个请求参数） // 第1个请求参数： name=will 参数名:name，参数值:will // 第2个请求参数： age=17 参数名:age , 参数值:17 String name = request.getParameter(&quot;name&quot;);//name就是请求参数名 String ageStr = request.getParameter(&quot;age&quot;);//age就是请求参数名 int age = Integer.parseInt(ageStr);//需要手动进行类型转换 System.out.println(name+&quot; : &quot;+age); return &quot;OK&quot;; }} ⚠️ ==注意==：以上这种方式，我们仅做了解。（在以后的开发中不会使用到） 1.2 SpringBoot方式 ( 掌握 )在Springboot的环境中，对原始的API进行了封装，接收参数的形式更加简单。 映射规则：如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。 1234567891011121314@RestControllerpublic class RequestController { // http://localhost:8080/simple?name=will&amp;age=10 // 请求参数： name=will&amp;age=17 （有2个请求参数） // 第1个请求参数： name=will 参数名:name，参数值:will // 第2个请求参数： age=17 参数名:age , 参数值:17 //springboot方式: 形参名和请求参数名保持一致 @RequestMapping(&quot;/simple&quot;) public String simpleParam(String name , Integer age ){ System.out.println(name+&quot; : &quot;+age); return &quot;OK&quot;; }} postman测试( GET 请求)： 那么，如何使用PostMan发送 POST请求呢？ postman测试( POST请求 )： 结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证==请求参数名和Controller方法中的形参名保持一致==，就可以获取到请求参数中的数据值。 1.3 参数名不一致如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？ 123456789101112@RestControllerpublic class RequestController { // http://localhost:8080/simple?name=will&amp;age=10 // 请求参数名：name // 请求参数名和形参名不相同 @RequestMapping(&quot;/simple&quot;) public String simpleParam(String username , Integer age ){ System.out.println(username+&quot; : &quot;+age); return &quot;OK&quot;; }} 答案：运行没有报错。 controller方法中的username值为：null，age值为20 结论：对于简单参数来讲，请求参数名和controller方法中的形参名不一致时，无法接收到请求数据 那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？ 解决方案：可以使用Spring提供的**@RequestParam**注解完成映射 在方法形参前面加上 @RequestParam 然后通过value属性设置请求参数名，从而完成映射。代码如下： 123456789101112@RestControllerpublic class RequestController { // http://localhost:8080/simpleParam?name=Tom&amp;age=20 // 请求参数名：name // springboot方式 @RequestMapping(&quot;/simple&quot;) public String simpleParam(@RequestParam(&quot;name&quot;) String username , Integer age ){ System.out.println(username+&quot; : &quot;+age); return &quot;OK&quot;; }} 2、实体参数在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。 此时，我们可以考虑将请求参数封装到一个实体类对象中。 要想完成数据封装，需要遵守如下规则：请求参数名与实体类的属性名相同 2.1 简单实体对象定义User实体类： 12345678@Getter@Setter@ToStringpublic class User { private String name; private Integer age;} Controller方法： 1234567891011@RestControllerpublic class RequestController { @RequestMapping(&quot;/entity&quot;) public String entity(User user) { System.out.println(&quot;user = &quot; + user); return &quot;OK&quot;; }} Postman测试： 参数名和实体类属性名一致时，可以映射成功 参数名和实体类属性名不一致时，映射不到属性为null 2.2 复杂实体对象复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的，例如：User类中有一个Address类型的属性（Address是一个实体类） 复杂实体对象的封装，需要遵守如下规则： 请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。 定义实体类： Address实体类 1234567@Getter@Setter@ToStringpublic class Address { private String province; private String city;} User实体类 1234567891011121314151617@Getter@Setter@ToStringpublic class User { private String name; private Integer age; private Address address; // 地址数据 @Override public String toString() { return &quot;User{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, address=&quot; + address + '}'; }} Controller方法： 123456789@RestControllerpublic class RequestController { // 实体参数：复杂实体对象 @RequestMapping(&quot;/entity&quot;) public String entity(User user) { System.out.println(&quot;user = &quot; + user); return &quot;OK&quot;; }} Postman测试： 3、数组集合参数数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。 多个值是怎么提交的呢？其实多个值也是一个一个的提交。 后端程序接收上述多个值的方式有两种： 数组 集合 3.1 数组数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数 Controller方法： 123456789@RestControllerpublic class RequestController { //数组集合参数 @RequestMapping(&quot;/array&quot;) public String array(String[] hobby){ System.out.println(Arrays.toString(hobby)); return &quot;OK&quot;; }} Postman测试： 在前端请求时，有两种传递形式： 方式一： xx?hobby=game&amp;hobby=java 方式二：xx?hobby=game,java 3.2 集合集合参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系 默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系 Controller方法： 12345678@RestControllerpublic class RequestController { @RequestMapping(&quot;/list&quot;) public String list(@RequestParam List&lt;String&gt; hobby) { System.out.println(&quot;hobby = &quot; + hobby); return &quot;OK&quot;; }} Postman测试：请自行测试 方式一： xx?hobby=game&amp;hobby=java 方式二：xx?hobby=game,java 4、日期参数上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求： 因为日期和时间格式多种多样（如：2024-04-27 10:05:45 、2024/04/27 10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过@DateTimeFormat注解，以及其pattern属性来设置日期的格式。 @DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。 后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。 Controller方法： 123456789@RestControllerpublic class RequestController { //日期时间参数 @RequestMapping(&quot;/date&quot;) public String date(@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) Date createTime) { System.out.println(&quot;createTime = &quot; + createTime); return &quot;OK&quot;; }} 5、JSON参数在学习前端技术时，我们有讲到过JSON，而在前后端进行交互时，如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式） 我们学习JSON格式参数，主要从以下两个方面着手： Postman在发送请求时，如何传递json格式的请求参数 在服务端的controller方法中，如何接收json格式的请求参数 Postman发送JSON格式数据： 服务端Controller方法接收JSON格式数据： 传递json格式的参数，在Controller中会使用实体类进行封装。 封装规则：JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody标识。 @RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致） 实体类：Address 1234567@Getter@Setter@ToStringpublic class Address { private String province; private String city;} 实体类：User 12345678@Getter@Setter@ToStringpublic class User { private String name; private Integer age; private Address address;} Controller方法： 123456789@RestControllerpublic class RequestController { //JSON参数 @RequestMapping(&quot;/json&quot;) public String json(@RequestBody User user){ System.out.println(user); return &quot;OK&quot;; }} 6、路径参数问题：传统的开发中，请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key=value的形式传递(GET请求)。 在现在的开发中，经常还会直接在请求的URL中传递参数。例如： 12http://localhost:8080/user/1 http://localhost:880/user/1/0 上述的这种传递请求参数的形式呢，我们称之为：路径参数 学习路径参数呢，主要掌握在后端的controller方法中，如何接收路径参数。 路径参数： 前端：通过请求URL直接传递参数 后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数 Controller方法： 123456789@RestControllerpublic class RequestController { //路径参数 @RequestMapping(&quot;/path/{id}&quot;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return &quot;OK&quot;; }} Postman测试： 传递多个路径参数： http://localhost:8080/path/1/will PostMan： Controller方法： 123456789@RestControllerpublic class RequestController { //路径参数 @RequestMapping(&quot;/path/{id}/{name}&quot;) public String pathParam2(@PathVariable Integer id, @PathVariable String name){ System.out.println(id+ &quot; : &quot; +name); return &quot;OK&quot;; }} 二、响应 Response前面我们学习HTML协议的交互方式：请求响应模式（有请求就有响应） 那么Controller程序呢，除了接收请求外，还可以进行响应。 在Web项目后，响应的方式有2种，一种Jsp页面，一种是JSON数据 1 响应 Jsp 页面需求：请求 http://localhost:8080/list 时，响应一个部门列表。 第一步：添加依赖。修改pom.xml 文件，添加如下依赖 1234567891011&lt;!--jsp页面使用jstl标签--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 使用jsp引擎，springboot内置tomcat没有此依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：创建webapp / views 目录，存放视图文件 第三步：配置视图文件前后缀。修改application.yml，添加如下配置： 123456# jsp 配置spring: mvc: view: prefix: /views/ #配置视图文件的前缀 suffix: .jsp #配置视图文件的后缀 第三步：在views目录下创建 list.jsp 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;雇员列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table width=&quot;600px&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;EMail&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;will&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;will@qq.com&lt;/td&gt; &lt;td&gt;17&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 第四部：创建 ResponseController 控制台，添加 @Controller 注解 123456789@Controllerpublic class ResponseController { @RequestMapping(&quot;/list&quot;) public String list() { return &quot;list&quot;; }} list 方法返回值表示jsp页面的位置，return “list” 实际是简写的路径，完整的路径是：/views/list.jsp 目前 list.jsp 页面都是静态的html，如果需要动态的显示数据（来自数据库或文件中），我们可以做以下调整 定义 Employee 类 12345678910111213@Getter@Setter@NoArgsConstructor@AllArgsConstructor@ToStringpublic class Employee { private Long id; private String name; private String password; private String email; private Integer age; private Boolean admin;} 修改控制器，添加雇员对象数据 123456789101112@Controllerpublic class ResponseController { @RequestMapping(&quot;/list&quot;) public String list(Model model) { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); employees.add(new Employee(1L,&quot;will&quot;,&quot;123&quot;,&quot;will@qq.com&quot;,17, true)); employees.add(new Employee(2L,&quot;alex&quot;,&quot;123&quot;,&quot;alex@qq.com&quot;,18, false)); model.addAttribute(&quot;employees&quot;, employees); return &quot;list&quot;; }} 修改 list. jsp 1234567891011121314151617181920212223&lt;table width=&quot;600px&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;EMail&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${employees}&quot; var=&quot;emp&quot;&gt; &lt;tr&gt; &lt;td&gt;${emp.id}&lt;/td&gt; &lt;td&gt;${emp.name}&lt;/td&gt; &lt;td&gt;${emp.password}&lt;/td&gt; &lt;td&gt;${emp.email}&lt;/td&gt; &lt;td&gt;${emp.age}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 2 响应JSON数据在我们前面所编写的controller方法中，都已经设置了响应数据。 controller方法中的return的结果，怎么就可以响应给浏览器呢？ 答案：使用@ResponseBody注解 @ResponseBody注解： 位置：书写在Controller方法上或类上 作用：将方法返回值直接响应给浏览器 如果返回值类型是字符串，直接把该字符串响应给浏览器 如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器 但是在我们所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？ 12345678@RestControllerpublic class HelloController { @RequestMapping(&quot;/hello&quot;) public String hello(){ System.out.println(&quot;Hello World ~&quot;); return &quot;Hello World ~&quot;; }} 原因：在类上添加的@RestController注解，是一个组合注解。 @RestController = @Controller + @ResponseBody @RestController源码： 1234567891011@Target({ElementType.TYPE}) //元注解（修饰注解的注解）@Retention(RetentionPolicy.RUNTIME) //元注解@Documented //元注解@Controller @ResponseBody public @interface RestController { @AliasFor( annotation = Controller.class ) String value() default &quot;&quot;;} 结论：在类上添加@RestController就相当于添加了@ResponseBody注解。 类上有@RestController注解或@ResponseBody注解时：表示当前类下所有的方法返回值做为响应数据 方法的返回值，如果是字符串，直接把该字符串响应给浏览器 方法的返回值，如果是一个POJO对象或集合时，会先转换为JSON格式，在响应给浏览器 下面我们来测试下响应数据： 12345678910111213141516171819202122232425262728293031323334@RestControllerpublic class ResponseController { //响应字符串 @RequestMapping(&quot;/hello&quot;) public String hello(){ System.out.println(&quot;Hello World ~&quot;); return &quot;Hello World ~&quot;; } //响应实体对象 @RequestMapping(&quot;/getAddr&quot;) public Address getAddr(){ Address addr = new Address();//创建实体类对象 addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); return addr; } //响应集合数据 @RequestMapping(&quot;/listAddr&quot;) public List&lt;Address&gt; listAddr(){ List&lt;Address&gt; list = new ArrayList&lt;&gt;();//集合对象 Address addr = new Address(); addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); Address addr2 = new Address(); addr2.setProvince(&quot;陕西&quot;); addr2.setCity(&quot;西安&quot;); list.add(addr); list.add(addr2); return list; }} 在服务端响应了一个对象或者集合，那私前端获取到的数据是什么样子的呢？我们使用postman发送请求来测试下。测试效果如下： 3 统一响应结果大家有没有发现一个问题，我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。 如果我们开发一个大型项目，项目中controller方法将成千上万，使用上述方式将造成整个项目难以维护。那在真实的项目开发中是什么样子的呢？ 在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下： 前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。 统一的返回结果使用类来描述，在这个结果中包含： 响应状态码：当前请求是成功，还是失败 状态码信息：给页面的提示信息 返回的数据：给前端响应的数据（字符串、对象、集合） 定义在一个实体类Result来包含以上信息。代码如下： 12345678910111213141516171819202122@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应码 描述字符串 private Object data; //返回的数据 // 增删改 成功响应(不需要给前端返回数据,也即不携带数据) public static Result success(){ return new Result(1,&quot;success&quot;,null); } // 查询 成功响应(把查询结果做为返回数据响应给前端，也即携带数据) public static Result success(Object data){ return new Result(1,&quot;success&quot;,data); } // 失败响应 public static Result error(String msg){ return new Result(0,msg,null); }} 改造Controller： 12345678910111213141516171819202122232425262728293031323334353637@RestControllerpublic class ResponseController { //响应统一格式的结果 @RequestMapping(&quot;/hello&quot;) public Result hello(){ System.out.println(&quot;Hello World ~&quot;); //return new Result(1,&quot;success&quot;,&quot;Hello World ~&quot;); return Result.success(&quot;Hello World ~&quot;); } //响应统一格式的结果 @RequestMapping(&quot;/getAddr&quot;) public Result getAddr(){ Address addr = new Address(); addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); return Result.success(addr); } //响应统一格式的结果 @RequestMapping(&quot;/listAddr&quot;) public Result listAddr(){ List&lt;Address&gt; list = new ArrayList&lt;&gt;(); Address addr = new Address(); addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); Address addr2 = new Address(); addr2.setProvince(&quot;陕西&quot;); addr2.setCity(&quot;西安&quot;); list.add(addr); list.add(addr2); return Result.success(list); }} 使用Postman测试： 三、请求响应综合应用下面我们通过一个案例，来加强对请求响应的学习。 2.3.1 需求说明需求：加载并解析xml文件中的数据，完成数据处理，并在页面展示 获取员工数据，返回统一响应结果，在页面渲染展示 2.3.2 准备工作案例准备： 1 XML文件 已经准备好(emps.xml)，直接导入进来，放在 src/main/resources目录下 2 工具类 已经准备好解析XML文件的工具类，无需自己实现 直接在创建一个包 cn.wolfcode.utils ，然后将工具类拷贝进来 3 前端页面资源 已经准备好，直接拷贝进来，放在src/main/resources下的static目录下 Springboot项目的静态资源(html，css，js等前端资源) 默认存放目录为：classpath:/static 、 classpath:/public、 classpath:/resources 在SpringBoot项目中，静态资源默认可以存放的目录： classpath:/static/ classpath:/public/ classpath:/resources/ classpath:/META-INF/resources/ classpath： 代表的是类路径，在maven的项目中，其实指的就是 src/main/resources 或者 src/main/java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在 src/main/resources下。 2.3.3 实现步骤1 在pom.xml文件中引入dom4j的依赖，用于解析XML文件 12345&lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 2 引入资料中提供的：解析XML的工具类XMLParserUtils、实体类Empoyee、XML文件emps.xml 3 引入资料中提供的静态页面文件，放在resources下的static目录下 4、创建EmployeeController类，编写Controller程序，处理请求，响应数据 2.3.4 代码实现Contriller代码： 1234567891011121314151617181920@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { @RequestMapping(&quot;/list&quot;) public Result list(){ //1 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); //2 对数据进行转换处理 employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); //3 响应数据 return Result.success(employees); }} 统一返回结果实体类： 12345678910111213141516171819@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Result { private Integer code ; //1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 data public static Result success(Object data){ return new Result(1, &quot;success&quot;, data); } public static Result success(){ return new Result(1, &quot;success&quot;, null); } public static Result error(String msg){ return new Result(0, msg, null); }} 2.3.5 测试代码编写完毕之后，我们就可以运行引导类，启动服务进行测试了。 使用Postman测试： 打开浏览器，在浏览器地址栏输入： http://localhost:8080/emp.html 2.3.6 存在问题分析上述案例的功能，我们虽然已经实现，但是呢，我们会发现案例中：解析XML数据，获取数据的代码，处理数据的逻辑的代码，给页面响应的代码全部都堆积在一起了，全部都写在controller方法中了。 当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。 当我们要修改操作数据部分的代码（例如：emps.xml换了位置），需要改动Controller 当我们要完善逻辑处理部分的代码，需要改动Controller 当我们需要修改数据响应的代码，还是需要改动Controller 这样呢，就会造成我们整个工程代码的耦合性太大，进而导致复用性差，而且代码难以维护。 那如何解决这个问题呢？其实在现在的开发中，有非常成熟的解决思路，那就是分层开发。 四、分层解耦1、三层架构1.1 介绍在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。 单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。 这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。 我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序： 那其实我们上述案例的逻辑呢，从组成上看可以分为三个部分： 数据访问：负责业务数据的维护操作，包括增、删、改、查等操作 逻辑处理：负责业务逻辑处理的代码 请求处理、响应数据：负责，接收页面的请求，给页面响应数据 按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层： Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。 Service：业务逻辑层。处理具体的业务逻辑。 Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。 基于三层架构的程序执行流程： 前端发起的请求，由Controller层接收（Controller响应数据给前端） Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层） Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取） Dao层操作文件中的数据（Dao拿到的数据会返回给Service层） 思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？ 答案：不会影响。 （程序的扩展性、维护性变得更好了） 1.2 代码拆分我们使用三层架构思想，来改造下之前的程序： 控制层包名：xx.controller 业务逻辑层包名：xx.service 数据访问层包名：xx.dao 控制层：接收前端发送的请求，对请求进行处理，并响应数据 123456789101112131415@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { // 业务层对象 private IEmployeeService employeeService = new EmployeeServiceImplA(); @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} 业务逻辑层：处理具体的业务逻辑 业务接口 123456//业务逻辑接口（制定业务规则、标准）public interface IEmployeeService { //获取员工列表 public List&lt;Employee&gt; list();} 业务实现类 123456789101112131415//业务逻辑实现类（按照业务标准实现）public class EmployeeServiceImplA implements IEmployeeService { // dao层对象 private IEmployeeDao employeeDao = new EmployeeDaoImplA(); @Override public List&lt;Employee&gt; list() { List&lt;Employee&gt; employees = employeeDao.selectAll(); employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); return employees; }} 数据访问层：负责数据的访问操作，包含数据的增、删、改、查 数据访问接口 12345//数据访问层接口（制定标准）public interface IEmployeeDao { //获取员工列表数据 public List&lt;Employee&gt; selectAll();} 数据访问实现类 123456789//数据访问实现类public class EmployeeDaoImplA implements IEmployeeDao { @Override public List&lt;Employee&gt; selectAll() { String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); return employees; }} 分层架构的流程图：画图 三层架构的好处： 复用性强 便于维护 利用扩展 2、分层解耦刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。 解耦：解除耦合。 2.1 耦合问题首先需要了解软件开发涉及到的两个概念：内聚和耦合。 内聚：软件中各个功能模块内部的功能联系。 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。 软件设计原则：高内聚低耦合。 高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。 低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。 程序中高内聚的体现： EmpServiceA类中只编写了和员工相关的逻辑处理代码 程序中耦合代码的体现： 把业务类变为EmpServiceB时，需要修改controller层中的代码 高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。 2.2 解耦思路之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后， 我们还需要修改controller层的代码。 那应该怎么解耦呢？ 1 首先不能在EmpController中使用new对象。代码如下： 1234567891011121314@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { // 业务层对象 private IEmployeeService employeeService; @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} 2 此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？ 3 我们的解决思路是： 提供一个容器，容器中存储一些对象(例：EmployeeServiceImplX对象) controller程序从容器中获取 EmployeeServiceImplX 类型的对象 我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念： 控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。 对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器 依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。 程序运行时需要某个资源，此时容器就为其提供这个资源。 例：EmployeeController程序运行时需要EmployeeServiceImplX 对象，Spring容器就为其提供并注入EmployeeServiceImplX 对象 IOC容器中创建、管理的对象，称之为：bean对象 3、IOC&amp;DI上面我们引出了Spring中IOC和DI的基本概念，下面我们就来具体学习下IOC和DI的代码实现。 3.1 IOC&amp;DI入门任务：完成Controller层、Service层、Dao层的代码解耦 思路： 删除Controller层、Service层中new对象的代码 Service层及Dao层的实现类，交给IOC容器管理 为Controller和Service注入运行时依赖的对象 Controller程序中注入依赖的Service层对象 Service程序中注入依赖的Dao层对象 第1步：删除Controller层、Service层中new对象的代码 第2步：Service层及Dao层的实现类，交给IOC容器管理 使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理 第3步：为Controller及Service注入运行时依赖的对象 使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象 完整的三层代码： Controller层： 1234567891011121314@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private IEmployeeService employeeService; @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} Service层： 12345678910111213141516@Component // 将当前对象交给IOC容器管理,成为IOC容器的beanpublic class EmployeeServiceImplA implements IEmployeeService { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private IEmployeeDao employeeDao; @Override public List&lt;Employee&gt; list() { List&lt;Employee&gt; employees = employeeDao.selectAll(); employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); return employees; }} Dao层： 123456789@Component //将当前对象交给IOC容器管理,成为IOC容器的beanpublic class EmployeeDaoImplA implements IEmployeeDao { @Override public List&lt;Employee&gt; selectAll() { String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); return employees; }} 运行测试： 启动SpringBoot引导类，打开浏览器，输入：http://localhost:8080/emp.html 3.2 IOC详解通过IOC和DI的入门程序呢，我们已经基本了解了IOC和DI的基础操作。接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。 3.3.2.1 bean的声明前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。 在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component 而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解： @Controller （标注在控制层类上） @Service （标注在业务层类上） @Repository （标注在数据访问层类上） 修改入门案例代码： Controller层： 1234567891011121314@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { @Autowired // 运行时,从IOC容器中获取该类型对象,赋值给该变量 private IEmployeeService employeeService; @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} Service层： 12345678910111213141516@Servicepublic class EmployeeServiceImplA implements IEmployeeService { @Autowired private IEmployeeDao employeeDao; @Override public List&lt;Employee&gt; list() { List&lt;Employee&gt; employees = employeeDao.selectAll(); employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); return employees; }} Dao层： 123456789@Repositorypublic class EmployeeDaoImplA implements IEmployeeDao { @Override public List&lt;Employee&gt; selectAll() { String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); return employees; }} 要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一： 注解 说明 位置 @Controller @Component的衍生注解 标注在控制器类上 @Service @Component的衍生注解 标注在业务类上 @Repository @Component的衍生注解 标注在数据访问类上（由于与mybatis整合，用的少） @Component 声明bean的基础注解 不属于以上三类时，用此注解 在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。 注意事项: 声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。 3.3.2.2 组件扫描问题：使用前面学习的四个注解声明的bean，一定会生效吗？ 答案：不一定。（原因：bean想要生效，还需要被组件扫描） 下面我们通过修改项目工程的目录结构，来测试bean对象是否生效： 运行程序后，报错： 为什么没有找到bean对象呢？ 使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描 @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，==默认扫描的范围是SpringBoot启动类所在包及其子包==。 解决方案：手动添加@ComponentScan注解，指定要扫描的包 （==仅做了解，不推荐==） 推荐做法（如下图）： 将我们定义的controller，service，dao这些包呢，都放在引导类所在包cn.wolfcode的子包下，这样我们定义的bean就会被自动的扫描到 3.3 DI详解上一小节我们讲解了控制反转IOC的细节，接下来呢，我们学习依赖注解DI的细节。 依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。 在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。 @Autowired注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作） 入门程序举例：在EmployeeController运行的时候，就要到IOC容器当中去查找 IEmployeeService 这个类型的对象，而我们的IOC容器中刚好有一个IEmployeeService 这个类型的对象，所以就找到了这个类型的对象完成注入操作。 那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？ 程序运行会报错 如何解决上述问题呢？Spring提供了以下几种解决方案： @Primary @Qualifier @Resource 使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。 使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用 使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。 面试题 ： @Autowird 与 @Resource的区别 @Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解 @Autowired 默认是按照类型注入，而@Resource是按照名称注入","link":"/2024/06/20/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/"}],"tags":[],"categories":[],"pages":[]}