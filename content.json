{"posts":[{"title":"","text":"Docker 使用教程Docker 的优点 ⼀致性和可移植性:Docker 容器可以在任何⽀持 Docker 的地⽅运⾏,⽆论是开 发者的本地机器、 测试环境还是⽣产环境。 隔离性:每个容器相互隔离,确保应⽤程序之间不会互相⼲扰。 效率:容器是轻量级的,它们共享操作系统内核,启动速度快,占⽤资源少。 版本控制和管理:Docker 允许你为应⽤程序创建和管理不同的版本。 Docker 的基本概念 镜像(Image):Docker 镜像是⼀个只读的模板,⽤于创建 Docker 容器。镜像可 以包含操作系 统、应⽤程序及其依赖项。 容器(Container):容器是由镜像创建的运⾏实例。它是⼀个轻量级、独⽴的执 ⾏环境。 Dockerfile:这是⼀个⽂本⽂件,包含⼀系列指令,⽤于⾃动化地构建 Docker 镜 像。 Docker Hub:这是⼀个公共的镜像仓库,可以从这⾥下载官⽅和社区维护的 Docker 镜像。 Docker Hub Container Image Library | App Containerization 安装 Docker DesktopDocker Desktop 是 Docker 官⽅提供的桌⾯版应⽤程序,它允许⽤户在 Windows 和 Mac 上轻松地使⽤ Docker。这个程序⾃带 docker-compose,因此不需要单独安装 Compose。 Windows 下安装Docker Desktop ⼀般需要 Windows10 及其以上版本,以下以 win10 系统为例 Docker Desktop 官⽅下载地址: https://docs.docker.com/desktop/install/windowsinstall/ 安装 Hyper-VHyper-V 是微软开发的虚拟机,类似于 VMWare 或 VirtualBox。这是 Docker Desktop for Windows 所使⽤的虚拟机。 但是,这个虚拟机⼀旦启⽤,QEMU、VirtualBox 或 VMWare Workstation 15 及以下 版本将⽆法使⽤!如果你必须在电脑上使⽤其他虚拟机(例如开发 Android 应⽤必须 使⽤的模拟器),请不要使⽤ Hyper-V! 开启 Hyper-V 程序和功能 启⽤或关闭 Windows 功能 选中 Hyper-V 也可以通过命令来启⽤ Hyper-V ,请右键开始菜单并以管理员身份运⾏ PowerShell, 执⾏以下命令: BashEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 安装 Docker Desktop for Windows点击 Get started with Docker Desktop,并下载 Windows 的版本,如果你还没有登录, 会要求注册登录: 运行安装文件双击下载的 Docker Desktop Installer 安装⽂件,⼀路 Next,点击 Finish 完成安装。 安装完成后,Docker 会⾃动启动。通知栏上会出现个小鲸鱼的图标,这表示 Docker 正在运⾏。 我们可以在命令⾏执⾏ docker -v 来查看版本号。 如果没启动,你可以在 Windows 搜索 Docker 来启动: 启动后,也可以在通知栏上看到小鲸鱼图标: 如果启动中遇到因 WSL 2 导致的错误,请安装 *WSL 2(https://learn.microsoft.com/zh-cn/windows/wsl/install)*。 安装之后,可以打开 PowerShell 并运⾏以下命令检测是否运⾏成功: 1234Bashdocker --version或者docker info 在成功运⾏之后应该会出现以下信息: Mac安装地址: Install Docker Desktop on Mac 。 如同 macOS 其它软件⼀样,安装也非常简单,双击下载的 .dmg ⽂件,然后将鲸鱼图 标拖拽到 Application ⽂件夹即可。 从应⽤中找到 Docker 图标并点击运⾏。可能会询问 macOS 的登陆密码,输入即可。 启动终端后,通过命令可以检查安装后的 Docker 版本。 12Bashdocker --version 镜像加速鉴于国内网络问题,后续拉取 Docker 镜像十分缓慢,我们可以需要配置加速器来解决。 Windows 和 Mac 配置⽅法⼀致。 点击 窗口顶端齿轮样的设置按钮 -&gt; Docker Engine 在输入窗中找到 registry-mirrors,在其下增加国内的 Docker 镜像地址: 12345678910111213141516171819202122232425&quot;registry-mirrors&quot;: [&quot;https://docker.registry.cyou&quot;,&quot;https://docker-cf.registry.cyou&quot;,&quot;https://dockercf.jsdelivr.fyi&quot;,&quot;https://docker.jsdelivr.fyi&quot;,&quot;https://dockertest.jsdelivr.fyi&quot;,&quot;https://mirror.aliyuncs.com&quot;,&quot;https://dockerproxy.com&quot;,&quot;https://mirror.baidubce.com&quot;,&quot;https://docker.m.daocloud.io&quot;,&quot;https://docker.nju.edu.cn&quot;,&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;,&quot;https://mirror.iscas.ac.cn&quot;,&quot;https://docker.rainbond.cc&quot;,&quot;https://do.nark.eu.org&quot;,&quot;https://dc.j8.work&quot;,&quot;https://dockerproxy.com&quot;,&quot;https://gst6rzl9.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;,&quot;http://mirrors.ustc.edu.cn/&quot;,&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;,&quot;http://mirrors.sohu.com/&quot;] 点击 Apply &amp; restart 按钮保存后 ,Docker 就会重启并应⽤配置的镜像地址了。 检查加速器是否生效检查加速器是否⽣效配置加速器之后,如果拉取镜像仍然十分缓慢,请手动检查加速 器配置是否⽣效,在命令⾏执⾏ docker info,如果从结果中看到了如下内容,说明配 置成功。 12Bashdocker info 目前,docker 的基本配置就已经完成了,接下来我们介绍⼀些常⽤的命令。 基本命令与使用命令⼀般需要在命令提示符窗口进⾏操作, 1. 运行容器下⾯以启动 Redis 服务的 docker 命令为例: 在第⼀次启动时可以使⽤命令或搜索 的⽅式启动。 123456python# -d: 后台运行容器# --name redis: 给容器起一个好记的名字# -p 7379:6379: 将本机的 7379 端口映射到容器的 6379 端口# redis:latest: 使用官方的 Redis 镜像docker run -d --name redis -p 7379:6379 redis:latest 这条命令会下载⼀个 redis 镜像并运⾏它。 在命令提示符成功运⾏后,⼀般我们可以在 Docker Desktop 窗口中看到。 在界⾯上通过右边”Actions”中的按钮即可启动和停止容器。 除了⽤命令启动,还可以通过搜索镜像名字来启动,这两种启动⽅式效果是⼀样的, 可任选其中⼀种。 以后再启动和停止 redis 容器时,只需要在界⾯上通过右边”Actions”中的按钮即可启动 和停止容器。 如果运⾏不成功,请点击当前容器条目所在⾏,进入日志窗口,检查运⾏失败原因 ⼀般来说,错误失败的原因大多数为:Docker 内容器之间的端口冲突了; Docker 内的容器端口和 Windows 中的程序端口冲突; 内存不足; 磁盘空间不够等原因 2. 查看运行的容器12pythondocker ps 这条命令会列出所有正在运⾏的容器。当然在 Docker Desktop 窗口中也可以看到当前 所有的容器及它们目前是否处于运⾏状态。 如果处于运⾏状态,则为正⽅形小块,三角形则表示容器未运⾏,点击三角形则会运 ⾏该容器,成功后同样变为正⽅形小块。 3. 停⽌容器可以在界⾯上通过右边”Actions”中的按钮。 也可以⽤命令的⽅式停止。 python docker stop [容器 ID] 替换 [容器 ID] 为 docker ps 命令中显示的实际容器 ID。 4. 删除容器以删除 docker 容器为例: 也可以⽤命令的⽅式。 12pythondocker rm [容器 ID] ⽤于删除已经停止的容器。如果容器正在运⾏,需要先停止容器,然后再删除。 5. 构建镜像创建⼀个名为 Dockerfile 的⽂件,然后运⾏: 12pythondocker build -t myimage . 这条命令会根据 Dockerfile 构建⼀个名为 myimage 的镜像。","link":"/2025/12/18/DockerDesktop%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"title":"Maven","text":"课程内容 初识Maven Maven概述 Maven模型介绍 Maven仓库介绍 Maven安装与配置 IDEA集成Maven 依赖管理 01. Maven课程介绍1.1 课程安排学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，后端Web开发技术是我们学习的重点。 后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven 1.2 初识Maven1.2.1 什么是MavenMaven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。 官网：https://maven.apache.org/ Apache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。 开源项目：https://www.apache.org/index.html#projects-list 1.2.2 Maven的作用使用Maven能够做什么呢？ 依赖管理 统一项目结构 项目构建 依赖管理： 方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题 当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。 **统一项目结构 : ** 提供标准、统一的项目结构 在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时： 若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构： 具体的统一结构如下： 目录说明： src/main/java: java源代码目录 src/main/resources: 配置文件信息 src/test/java: 测试代码 src/test/resources: 测试配置文件信息 项目构建 : maven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。 综上所述，可以得到一个结论：Maven是一款管理和构建java项目的工具 02. Maven概述2.1 Maven介绍Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。 官网：https://maven.apache.org/ Maven的作用： 方便的依赖管理 统一的项目结构 标准的项目构建流程 2.2 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 构建生命周期/阶段(Build lifecycle &amp; phases) 1). 构建生命周期/阶段(Build lifecycle &amp; phases) 以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。 2). 项目对象模型 (Project Object Model) 以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目： 坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置 3). 依赖管理模型(Dependency) 以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包 之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在书写在pom.xml文件中的坐标又是怎么能找到所要的jar包文件的呢？ 答案：Maven仓库 2.3 Maven仓库仓库：用于存储资源，管理各种jar包 仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件 Maven仓库分为： 本地仓库：自己计算机上的一个目录(用来存储jar包) 中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包 如果有，则在项目直接引用 如果没有，则去中央仓库中下载对应的jar包到本地仓库 如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库 2.4 Maven安装认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。 2.4.1 下载下载地址：https://maven.apache.org/download.cgi 在提供的资料中，已经提供了下载好的安装包。如下： 2.4.2 安装步骤Maven安装配置步骤： 解压安装 配置仓库 配置Maven环境变量 1、解压 apache-maven-3.6.1-bin.zip（解压即安装） 建议解压到没有中文、特殊字符的路径下。如课程中解压到 E:\\develop 下。 解压缩后的目录结构如下： bin目录 ： 存放的是可执行命令。（mvn 命令重点关注） conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改） lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包） 2、配置本地仓库 2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包） 2.2、进入到conf目录下修改settings.xml配置文件 1). 使用超级记事本软件，打开settings.xml文件，定位到53行 2). 复制标签，粘贴到注释的外面（55行） 3). 复制之前新建的用来存储jar包的路径，替换掉标签体内容 3、配置阿里云私服 由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。 进入到conf目录下修改settings.xml配置文件： 1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右 2). 在标签下为其添加子标签，内容如下： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 注意配置的位置，在 … 中间添加配置。如下图所示： ==注: 只可配置一个(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!== 4、配置环境变量 Maven环境变量的配置类似于JDK环境变量配置一样 1). 在系统变量处新建一个变量MAVEN_HOME MAVEN_HOME环境变量的值，设置为maven的解压安装目录 2). 在Path中进行配置 PATH环境变量的值，设置为：%MAVEN_HOME%\\bin 3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功 1mvn -v 03. IDEA集成Maven我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven 3.1 配置Maven环境3.1.1 当前工程设置1、选择 IDEA中 File =&gt; Settings =&gt; Build,Execution,Deployment =&gt; Build Tools =&gt; Maven 2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径 Maven home path ：指定当前Maven的安装目录 User settings file ：指定当前Maven的settings.xml配置文件的存放路径 Local repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定) 3、配置工程的编译版本为11 Maven默认使用的编译版本为5（版本过低） 上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。 3.1.2 全局设置1、进入到IDEA欢迎页面 选择 IDEA中 File =&gt; close project 2、打开 All settings , 选择 Build,Execution,Deployment =&gt; Build Tools =&gt; Maven 3、配置工程的编译版本为11 这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。 3.2 Maven项目3.2.1 创建Maven项目1、创建一个空项目 2、创建模块，选择Maven，点击Next 3、填写模块名称，坐标信息，点击finish，创建完成 4、在Maven工程下，创建HelloWorld类 Maven项目的目录结构: maven-project01|— src (源代码目录和测试代码目录) |— main (源代码目录) |— java (源代码java文件目录) |— resources (源代码配置文件目录) |— test (测试代码目录) |— java (测试代码java目录) |— resources (测试代码配置文件目录)|— target (编译、打包生成文件存放目录) 5、编写 HelloWorld，并运行 12345public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello Maven ...&quot;); }} 3.2.2 POM配置详解POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。 使用pom.xml文件来实现 pom.xml文件： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- POM模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 当前项目坐标 --&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_project1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;/project&gt; pom文件详解： ：pom文件的根标签，表示当前maven项目 ：声明项目描述遵循哪一个POM模型版本 虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0 坐标 ：、、 定位项目在本地仓库中的位置，由以上三个标签组成一个坐标 ：maven项目的打包方式，通常设置为jar或war（默认值：jar） 3.2.3 Maven坐标详解什么是坐标？ Maven中的坐标是==资源的唯一标识== , 通过该坐标可以唯一定位资源位置 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目： 注意： 上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 3.3 导入Maven项目 方式1：使用Maven面板，快速导入项目 打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可 说明：如果没有Maven面板，选择 View =&gt; Appearance =&gt; Tool Window Bars 方式2：使用idea导入模块项目 File =&gt; Project Structure =&gt; Modules =&gt; + =&gt; Import Module 找到要导入工程的pom.xml 04. 依赖管理4.1 依赖配置依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖： 例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下： 在pom.xml中编写标签 在标签中使用引入坐标 定义坐标的 groupId、artifactId、version 1234567891011121314&lt;dependencies&gt; &lt;!-- 第1个依赖 : logback --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 第2个依赖 : junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 点击刷新按钮，引入最新加入的坐标 刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标 注意事项： 如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待） 如果不知道依赖的坐标信息，可以到mvn的中央仓库（https://mvnrepository.com/）中搜索 添加依赖的几种方式： 利用中央仓库搜索的依赖坐标 利用IDEA工具搜索依赖 熟练上手maven后，快速导入依赖 4.2 依赖传递4.2.1 依赖具有传递性早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下 我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。 在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。 依赖传递可以分为： 直接依赖：在当前项目中通过依赖配置建立的依赖关系 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 比如以上图中： projectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。 而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。 4.2.2 排除依赖问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？ 答案：在maven项目中，我们可以通过排除依赖来实现。 什么是排除依赖？ 排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本） 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven-projectB&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--排除依赖, 主动断开依赖的资源--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 依赖排除示例： maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit 使用排除依赖后 4.3 依赖范围在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。 如果希望限制依赖的使用范围，可以通过标签设置其作用范围。 作用范围： 主程序范围有效（main文件夹范围内） 测试程序范围有效（test文件夹范围内） 是否参与打包运行（package指令范围内） 如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。 scope标签的取值范围： scope值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 4.4 生命周期4.4.1 介绍Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。 在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。 Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。 Maven对项目构建的生命周期划分为3套（相互独立）： clean：清理工作。 default：核心工作。如：编译、测试、打包、安装、部署等。 site：生成报告、发布站点等。 三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图: 我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个： • clean：移除上一次构建生成的文件 • compile：编译项目源代码 • test：使用合适的单元测试框架运行测试(junit) • package：将编译后的文件打包，如：jar、war等 • install：安装项目到本地仓库 Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。 IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道 生命周期的顺序是：clean –&gt; validate –&gt; compile –&gt; test –&gt; package –&gt; verify –&gt; install –&gt; site –&gt; deploy 我们需要关注的就是：clean –&gt; compile –&gt; test –&gt; package –&gt; install 说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。 思考：当运行package生命周期时，clean、compile生命周期会不会运行？ ​ clean不会运行，compile会运行。 因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。 4.4.2 执行在日常开发中，当我们要执行指定的生命周期时，有两种执行方式： 在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行 在DOS命令行中，通过maven命令执行 方式一：在idea中执行生命周期 选择对应的生命周期，双击执行 compile： test： package： install： clean： 方式二：在命令行中执行生命周期 进入到DOS命令行 05. 附录5.1 更新依赖索引有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下： 打开设置—-搜索maven—-Repositories—-选中本地仓库—–点击Update 5.2 清理maven仓库初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。 如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除： 1234567set REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_reporem 正在搜索...del /s /q %REPOSITORY_PATH%\\*.lastUpdatedrem 搜索完毕pause 操作步骤如下： 1). 定义批处理文件del_lastUpdated.bat (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 ) 2). 在上面的bat文件上右键—》编辑 。修改文件： 修改完毕后，双击运行即可删除maven仓库中的残留文件。","link":"/2024/06/19/Maven/"},{"title":"README","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 基本操作说明快速开始创建一篇新文章1$ hexo new &quot;文章标题&quot; More info: Writing 运行本地服务1$ hexo server More info: Server 清除已生成文件和缓存1$ hexo clean More info: Clean 生成静态页面1$ hexo generate More info: Generating 部署到远端站点1$ hexo deploy More info: Deployment 控制台指令列表123456789101112131415161718192021222324Usage: hexo &lt;command&gt;Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on console","link":"/2025/07/06/README/"},{"title":"SpringBootWeb请求响应","text":"请求Request 必须掌握各种请求参数的映射规则 响应Response 了解后台响应前端的形式：Jsp和JSON 必须掌握JSON响应方式 掌握前后端分离统一响应的处理方式 请求响应综合应用 必须掌握雇员列表展示综合应用 分层架构 必须掌握分层架构思想 知道解耦思想 必须掌握IoC和DI 前言在上一次的课程中，我们开发了springbootweb的入门程序。 基于SpringBoot的方式开发一个web应用，浏览器发起请求 /hello 后 ，给浏览器返回字符串 “Hello World ~”。 其实呢，是我们在浏览器发起请求，请求了我们的后端web服务器(也就是内置的Tomcat)。而我们在开发web程序时呢，定义了一个控制器类Controller，请求会被部署在Tomcat中的Controller接收，然后Controller再给浏览器一个响应，响应一个字符串 “Hello World”。 而在请求响应的过程中是遵循HTTP协议的。 但是呢，这里要告诉大家的时，其实在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别 Servlet程序的。 那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？ 其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据。 那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后呢将解析后的请求数据会传递给Servlet程序的HttpServletRequest对象，那也就意味着 HttpServletRequest 对象就可以获取到请求数据。 而Tomcat，还给Servlet程序传递了一个参数 HttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。 123456789@WebServlet(&quot;/hello&quot;) public HelloServlet extends HttpServlet { public void service(HttpServletRequest request, HttpServletResponse response ) { // 接受浏览器请求 // 业务 // 向浏览器响应数据 }} 那上述所描述的这种浏览器/服务器的架构模式呢，我们称之为：BS架构。 • BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。 那今天呢，我们的课程内容主要就围绕着：请求、响应进行。 今天课程内容，主要包含三个部分： 请求 响应 分层解耦 一、请求 Request在本章节呢，我们主要讲解，如何接收页面传递过来的请求数据。 之前我们课程中有提到当前最为主流的开发模式：前后端分离 在这种模式下，前端技术人员基于”接口文档”，开发前端程序；后端技术人员也基于”接口文档”，开发后端程序。 由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？ 方式1：像之前SpringBoot入门案例中一样，直接使用浏览器。在浏览器中输入地址，测试后端程序。 弊端：在浏览器地址栏中输入地址这种方式都是GET请求，如何我们要用到POST请求怎么办呢？ 要解决POST请求，需要程序员自己编写前端代码（比较麻烦） 方式2：使用专业的接口测试工具（课程中我们使用Postman工具） 1、简单参数简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。 那么在后端程序中，如何接收传递过来的普通参数数据呢？ 我们在这里讲解两种方式： 原始方式 SpringBoot方式 1.1 原始方式 ( 了解 )在原始的Web程序当中，需要通过Servlet中提供的API——HttpServletRequest（请求对象）来获取请求的相关信息，比如获取请求参数。Tomcat接收到http请求时，把请求的相关信息封装到HttpServletRequest对象中 在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明 HttpServletRequest 对象。然后就可以通过该对象来获取请求信息： HttpServletRequest 常用方法 功能 String getParameter( 参数名 ) 从请求对象HttpServletRequest中获取请求参数的数据值 123456789101112131415161718@RestControllerpublic class RequestController { //原始方式 @RequestMapping(&quot;/simple&quot;) public String simpleParam(HttpServletRequest request){ // http://localhost:8080/simple?name=will&amp;age=10 // 请求参数： name=will&amp;age=17 （有2个请求参数） // 第1个请求参数： name=will 参数名:name，参数值:will // 第2个请求参数： age=17 参数名:age , 参数值:17 String name = request.getParameter(&quot;name&quot;);//name就是请求参数名 String ageStr = request.getParameter(&quot;age&quot;);//age就是请求参数名 int age = Integer.parseInt(ageStr);//需要手动进行类型转换 System.out.println(name+&quot; : &quot;+age); return &quot;OK&quot;; }} ⚠️ ==注意==：以上这种方式，我们仅做了解。（在以后的开发中不会使用到） 1.2 SpringBoot方式 ( 掌握 )在Springboot的环境中，对原始的API进行了封装，接收参数的形式更加简单。 映射规则：如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。 1234567891011121314@RestControllerpublic class RequestController { // http://localhost:8080/simple?name=will&amp;age=10 // 请求参数： name=will&amp;age=17 （有2个请求参数） // 第1个请求参数： name=will 参数名:name，参数值:will // 第2个请求参数： age=17 参数名:age , 参数值:17 //springboot方式: 形参名和请求参数名保持一致 @RequestMapping(&quot;/simple&quot;) public String simpleParam(String name , Integer age ){ System.out.println(name+&quot; : &quot;+age); return &quot;OK&quot;; }} postman测试( GET 请求)： 那么，如何使用PostMan发送 POST请求呢？ postman测试( POST请求 )： 结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证==请求参数名和Controller方法中的形参名保持一致==，就可以获取到请求参数中的数据值。 1.3 参数名不一致如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？ 123456789101112@RestControllerpublic class RequestController { // http://localhost:8080/simple?name=will&amp;age=10 // 请求参数名：name // 请求参数名和形参名不相同 @RequestMapping(&quot;/simple&quot;) public String simpleParam(String username , Integer age ){ System.out.println(username+&quot; : &quot;+age); return &quot;OK&quot;; }} 答案：运行没有报错。 controller方法中的username值为：null，age值为20 结论：对于简单参数来讲，请求参数名和controller方法中的形参名不一致时，无法接收到请求数据 那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？ 解决方案：可以使用Spring提供的**@RequestParam**注解完成映射 在方法形参前面加上 @RequestParam 然后通过value属性设置请求参数名，从而完成映射。代码如下： 123456789101112@RestControllerpublic class RequestController { // http://localhost:8080/simpleParam?name=Tom&amp;age=20 // 请求参数名：name // springboot方式 @RequestMapping(&quot;/simple&quot;) public String simpleParam(@RequestParam(&quot;name&quot;) String username , Integer age ){ System.out.println(username+&quot; : &quot;+age); return &quot;OK&quot;; }} 2、实体参数在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。 此时，我们可以考虑将请求参数封装到一个实体类对象中。 要想完成数据封装，需要遵守如下规则：请求参数名与实体类的属性名相同 2.1 简单实体对象定义User实体类： 12345678@Getter@Setter@ToStringpublic class User { private String name; private Integer age;} Controller方法： 1234567891011@RestControllerpublic class RequestController { @RequestMapping(&quot;/entity&quot;) public String entity(User user) { System.out.println(&quot;user = &quot; + user); return &quot;OK&quot;; }} Postman测试： 参数名和实体类属性名一致时，可以映射成功 参数名和实体类属性名不一致时，映射不到属性为null 2.2 复杂实体对象复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的，例如：User类中有一个Address类型的属性（Address是一个实体类） 复杂实体对象的封装，需要遵守如下规则： 请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。 定义实体类： Address实体类 1234567@Getter@Setter@ToStringpublic class Address { private String province; private String city;} User实体类 1234567891011121314151617@Getter@Setter@ToStringpublic class User { private String name; private Integer age; private Address address; // 地址数据 @Override public String toString() { return &quot;User{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, address=&quot; + address + '}'; }} Controller方法： 123456789@RestControllerpublic class RequestController { // 实体参数：复杂实体对象 @RequestMapping(&quot;/entity&quot;) public String entity(User user) { System.out.println(&quot;user = &quot; + user); return &quot;OK&quot;; }} Postman测试： 3、数组集合参数数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。 多个值是怎么提交的呢？其实多个值也是一个一个的提交。 后端程序接收上述多个值的方式有两种： 数组 集合 3.1 数组数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数 Controller方法： 123456789@RestControllerpublic class RequestController { //数组集合参数 @RequestMapping(&quot;/array&quot;) public String array(String[] hobby){ System.out.println(Arrays.toString(hobby)); return &quot;OK&quot;; }} Postman测试： 在前端请求时，有两种传递形式： 方式一： xx?hobby=game&amp;hobby=java 方式二：xx?hobby=game,java 3.2 集合集合参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系 默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系 Controller方法： 12345678@RestControllerpublic class RequestController { @RequestMapping(&quot;/list&quot;) public String list(@RequestParam List&lt;String&gt; hobby) { System.out.println(&quot;hobby = &quot; + hobby); return &quot;OK&quot;; }} Postman测试：请自行测试 方式一： xx?hobby=game&amp;hobby=java 方式二：xx?hobby=game,java 4、日期参数上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求： 因为日期和时间格式多种多样（如：2024-04-27 10:05:45 、2024/04/27 10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过@DateTimeFormat注解，以及其pattern属性来设置日期的格式。 @DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。 后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。 Controller方法： 123456789@RestControllerpublic class RequestController { //日期时间参数 @RequestMapping(&quot;/date&quot;) public String date(@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) Date createTime) { System.out.println(&quot;createTime = &quot; + createTime); return &quot;OK&quot;; }} 5、JSON参数在学习前端技术时，我们有讲到过JSON，而在前后端进行交互时，如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式） 我们学习JSON格式参数，主要从以下两个方面着手： Postman在发送请求时，如何传递json格式的请求参数 在服务端的controller方法中，如何接收json格式的请求参数 Postman发送JSON格式数据： 服务端Controller方法接收JSON格式数据： 传递json格式的参数，在Controller中会使用实体类进行封装。 封装规则：JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody标识。 @RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致） 实体类：Address 1234567@Getter@Setter@ToStringpublic class Address { private String province; private String city;} 实体类：User 12345678@Getter@Setter@ToStringpublic class User { private String name; private Integer age; private Address address;} Controller方法： 123456789@RestControllerpublic class RequestController { //JSON参数 @RequestMapping(&quot;/json&quot;) public String json(@RequestBody User user){ System.out.println(user); return &quot;OK&quot;; }} 6、路径参数问题：传统的开发中，请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key=value的形式传递(GET请求)。 在现在的开发中，经常还会直接在请求的URL中传递参数。例如： 12http://localhost:8080/user/1 http://localhost:880/user/1/0 上述的这种传递请求参数的形式呢，我们称之为：路径参数 学习路径参数呢，主要掌握在后端的controller方法中，如何接收路径参数。 路径参数： 前端：通过请求URL直接传递参数 后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数 Controller方法： 123456789@RestControllerpublic class RequestController { //路径参数 @RequestMapping(&quot;/path/{id}&quot;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return &quot;OK&quot;; }} Postman测试： 传递多个路径参数： http://localhost:8080/path/1/will PostMan： Controller方法： 123456789@RestControllerpublic class RequestController { //路径参数 @RequestMapping(&quot;/path/{id}/{name}&quot;) public String pathParam2(@PathVariable Integer id, @PathVariable String name){ System.out.println(id+ &quot; : &quot; +name); return &quot;OK&quot;; }} 二、响应 Response前面我们学习HTML协议的交互方式：请求响应模式（有请求就有响应） 那么Controller程序呢，除了接收请求外，还可以进行响应。 在Web项目后，响应的方式有2种，一种Jsp页面，一种是JSON数据 1 响应 Jsp 页面需求：请求 http://localhost:8080/list 时，响应一个部门列表。 第一步：添加依赖。修改pom.xml 文件，添加如下依赖 1234567891011&lt;!--jsp页面使用jstl标签--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 使用jsp引擎，springboot内置tomcat没有此依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：创建webapp / views 目录，存放视图文件 第三步：配置视图文件前后缀。修改application.yml，添加如下配置： 123456# jsp 配置spring: mvc: view: prefix: /views/ #配置视图文件的前缀 suffix: .jsp #配置视图文件的后缀 第三步：在views目录下创建 list.jsp 123456789101112131415161718192021222324252627282930313233&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;雇员列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table width=&quot;600px&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;EMail&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;will&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;will@qq.com&lt;/td&gt; &lt;td&gt;17&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 第四部：创建 ResponseController 控制台，添加 @Controller 注解 123456789@Controllerpublic class ResponseController { @RequestMapping(&quot;/list&quot;) public String list() { return &quot;list&quot;; }} list 方法返回值表示jsp页面的位置，return “list” 实际是简写的路径，完整的路径是：/views/list.jsp 目前 list.jsp 页面都是静态的html，如果需要动态的显示数据（来自数据库或文件中），我们可以做以下调整 定义 Employee 类 12345678910111213@Getter@Setter@NoArgsConstructor@AllArgsConstructor@ToStringpublic class Employee { private Long id; private String name; private String password; private String email; private Integer age; private Boolean admin;} 修改控制器，添加雇员对象数据 123456789101112@Controllerpublic class ResponseController { @RequestMapping(&quot;/list&quot;) public String list(Model model) { List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); employees.add(new Employee(1L,&quot;will&quot;,&quot;123&quot;,&quot;will@qq.com&quot;,17, true)); employees.add(new Employee(2L,&quot;alex&quot;,&quot;123&quot;,&quot;alex@qq.com&quot;,18, false)); model.addAttribute(&quot;employees&quot;, employees); return &quot;list&quot;; }} 修改 list. jsp 1234567891011121314151617181920212223&lt;table width=&quot;600px&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;EMail&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${employees}&quot; var=&quot;emp&quot;&gt; &lt;tr&gt; &lt;td&gt;${emp.id}&lt;/td&gt; &lt;td&gt;${emp.name}&lt;/td&gt; &lt;td&gt;${emp.password}&lt;/td&gt; &lt;td&gt;${emp.email}&lt;/td&gt; &lt;td&gt;${emp.age}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 2 响应JSON数据在我们前面所编写的controller方法中，都已经设置了响应数据。 controller方法中的return的结果，怎么就可以响应给浏览器呢？ 答案：使用@ResponseBody注解 @ResponseBody注解： 位置：书写在Controller方法上或类上 作用：将方法返回值直接响应给浏览器 如果返回值类型是字符串，直接把该字符串响应给浏览器 如果返回值类型是实体对象/集合，将会转换为JSON格式后在响应给浏览器 但是在我们所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？ 12345678@RestControllerpublic class HelloController { @RequestMapping(&quot;/hello&quot;) public String hello(){ System.out.println(&quot;Hello World ~&quot;); return &quot;Hello World ~&quot;; }} 原因：在类上添加的@RestController注解，是一个组合注解。 @RestController = @Controller + @ResponseBody @RestController源码： 1234567891011@Target({ElementType.TYPE}) //元注解（修饰注解的注解）@Retention(RetentionPolicy.RUNTIME) //元注解@Documented //元注解@Controller @ResponseBody public @interface RestController { @AliasFor( annotation = Controller.class ) String value() default &quot;&quot;;} 结论：在类上添加@RestController就相当于添加了@ResponseBody注解。 类上有@RestController注解或@ResponseBody注解时：表示当前类下所有的方法返回值做为响应数据 方法的返回值，如果是字符串，直接把该字符串响应给浏览器 方法的返回值，如果是一个POJO对象或集合时，会先转换为JSON格式，在响应给浏览器 下面我们来测试下响应数据： 12345678910111213141516171819202122232425262728293031323334@RestControllerpublic class ResponseController { //响应字符串 @RequestMapping(&quot;/hello&quot;) public String hello(){ System.out.println(&quot;Hello World ~&quot;); return &quot;Hello World ~&quot;; } //响应实体对象 @RequestMapping(&quot;/getAddr&quot;) public Address getAddr(){ Address addr = new Address();//创建实体类对象 addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); return addr; } //响应集合数据 @RequestMapping(&quot;/listAddr&quot;) public List&lt;Address&gt; listAddr(){ List&lt;Address&gt; list = new ArrayList&lt;&gt;();//集合对象 Address addr = new Address(); addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); Address addr2 = new Address(); addr2.setProvince(&quot;陕西&quot;); addr2.setCity(&quot;西安&quot;); list.add(addr); list.add(addr2); return list; }} 在服务端响应了一个对象或者集合，那私前端获取到的数据是什么样子的呢？我们使用postman发送请求来测试下。测试效果如下： 3 统一响应结果大家有没有发现一个问题，我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。 如果我们开发一个大型项目，项目中controller方法将成千上万，使用上述方式将造成整个项目难以维护。那在真实的项目开发中是什么样子的呢？ 在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下： 前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。 统一的返回结果使用类来描述，在这个结果中包含： 响应状态码：当前请求是成功，还是失败 状态码信息：给页面的提示信息 返回的数据：给前端响应的数据（字符串、对象、集合） 定义在一个实体类Result来包含以上信息。代码如下： 12345678910111213141516171819202122@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应码 描述字符串 private Object data; //返回的数据 // 增删改 成功响应(不需要给前端返回数据,也即不携带数据) public static Result success(){ return new Result(1,&quot;success&quot;,null); } // 查询 成功响应(把查询结果做为返回数据响应给前端，也即携带数据) public static Result success(Object data){ return new Result(1,&quot;success&quot;,data); } // 失败响应 public static Result error(String msg){ return new Result(0,msg,null); }} 改造Controller： 12345678910111213141516171819202122232425262728293031323334353637@RestControllerpublic class ResponseController { //响应统一格式的结果 @RequestMapping(&quot;/hello&quot;) public Result hello(){ System.out.println(&quot;Hello World ~&quot;); //return new Result(1,&quot;success&quot;,&quot;Hello World ~&quot;); return Result.success(&quot;Hello World ~&quot;); } //响应统一格式的结果 @RequestMapping(&quot;/getAddr&quot;) public Result getAddr(){ Address addr = new Address(); addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); return Result.success(addr); } //响应统一格式的结果 @RequestMapping(&quot;/listAddr&quot;) public Result listAddr(){ List&lt;Address&gt; list = new ArrayList&lt;&gt;(); Address addr = new Address(); addr.setProvince(&quot;广东&quot;); addr.setCity(&quot;深圳&quot;); Address addr2 = new Address(); addr2.setProvince(&quot;陕西&quot;); addr2.setCity(&quot;西安&quot;); list.add(addr); list.add(addr2); return Result.success(list); }} 使用Postman测试： 三、请求响应综合应用下面我们通过一个案例，来加强对请求响应的学习。 2.3.1 需求说明需求：加载并解析xml文件中的数据，完成数据处理，并在页面展示 获取员工数据，返回统一响应结果，在页面渲染展示 2.3.2 准备工作案例准备： 1 XML文件 已经准备好(emps.xml)，直接导入进来，放在 src/main/resources目录下 2 工具类 已经准备好解析XML文件的工具类，无需自己实现 直接在创建一个包 cn.wolfcode.utils ，然后将工具类拷贝进来 3 前端页面资源 已经准备好，直接拷贝进来，放在src/main/resources下的static目录下 Springboot项目的静态资源(html，css，js等前端资源) 默认存放目录为：classpath:/static 、 classpath:/public、 classpath:/resources 在SpringBoot项目中，静态资源默认可以存放的目录： classpath:/static/ classpath:/public/ classpath:/resources/ classpath:/META-INF/resources/ classpath： 代表的是类路径，在maven的项目中，其实指的就是 src/main/resources 或者 src/main/java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在 src/main/resources下。 2.3.3 实现步骤1 在pom.xml文件中引入dom4j的依赖，用于解析XML文件 12345&lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt; 2 引入资料中提供的：解析XML的工具类XMLParserUtils、实体类Empoyee、XML文件emps.xml 3 引入资料中提供的静态页面文件，放在resources下的static目录下 4、创建EmployeeController类，编写Controller程序，处理请求，响应数据 2.3.4 代码实现Contriller代码： 1234567891011121314151617181920@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { @RequestMapping(&quot;/list&quot;) public Result list(){ //1 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); //2 对数据进行转换处理 employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); //3 响应数据 return Result.success(employees); }} 统一返回结果实体类： 12345678910111213141516171819@Getter@Setter@AllArgsConstructor@NoArgsConstructorpublic class Result { private Integer code ; //1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 data public static Result success(Object data){ return new Result(1, &quot;success&quot;, data); } public static Result success(){ return new Result(1, &quot;success&quot;, null); } public static Result error(String msg){ return new Result(0, msg, null); }} 2.3.5 测试代码编写完毕之后，我们就可以运行引导类，启动服务进行测试了。 使用Postman测试： 打开浏览器，在浏览器地址栏输入： http://localhost:8080/emp.html 2.3.6 存在问题分析上述案例的功能，我们虽然已经实现，但是呢，我们会发现案例中：解析XML数据，获取数据的代码，处理数据的逻辑的代码，给页面响应的代码全部都堆积在一起了，全部都写在controller方法中了。 当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。 当我们要修改操作数据部分的代码（例如：emps.xml换了位置），需要改动Controller 当我们要完善逻辑处理部分的代码，需要改动Controller 当我们需要修改数据响应的代码，还是需要改动Controller 这样呢，就会造成我们整个工程代码的耦合性太大，进而导致复用性差，而且代码难以维护。 那如何解决这个问题呢？其实在现在的开发中，有非常成熟的解决思路，那就是分层开发。 四、分层解耦1、三层架构1.1 介绍在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。 单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。 这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。 我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序： 那其实我们上述案例的逻辑呢，从组成上看可以分为三个部分： 数据访问：负责业务数据的维护操作，包括增、删、改、查等操作 逻辑处理：负责业务逻辑处理的代码 请求处理、响应数据：负责，接收页面的请求，给页面响应数据 按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层： Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。 Service：业务逻辑层。处理具体的业务逻辑。 Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。 基于三层架构的程序执行流程： 前端发起的请求，由Controller层接收（Controller响应数据给前端） Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层） Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取） Dao层操作文件中的数据（Dao拿到的数据会返回给Service层） 思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？ 答案：不会影响。 （程序的扩展性、维护性变得更好了） 1.2 代码拆分我们使用三层架构思想，来改造下之前的程序： 控制层包名：xx.controller 业务逻辑层包名：xx.service 数据访问层包名：xx.dao 控制层：接收前端发送的请求，对请求进行处理，并响应数据 123456789101112131415@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { // 业务层对象 private IEmployeeService employeeService = new EmployeeServiceImplA(); @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} 业务逻辑层：处理具体的业务逻辑 业务接口 123456//业务逻辑接口（制定业务规则、标准）public interface IEmployeeService { //获取员工列表 public List&lt;Employee&gt; list();} 业务实现类 123456789101112131415//业务逻辑实现类（按照业务标准实现）public class EmployeeServiceImplA implements IEmployeeService { // dao层对象 private IEmployeeDao employeeDao = new EmployeeDaoImplA(); @Override public List&lt;Employee&gt; list() { List&lt;Employee&gt; employees = employeeDao.selectAll(); employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); return employees; }} 数据访问层：负责数据的访问操作，包含数据的增、删、改、查 数据访问接口 12345//数据访问层接口（制定标准）public interface IEmployeeDao { //获取员工列表数据 public List&lt;Employee&gt; selectAll();} 数据访问实现类 123456789//数据访问实现类public class EmployeeDaoImplA implements IEmployeeDao { @Override public List&lt;Employee&gt; selectAll() { String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); return employees; }} 分层架构的流程图：画图 三层架构的好处： 复用性强 便于维护 利用扩展 2、分层解耦刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。 解耦：解除耦合。 2.1 耦合问题首先需要了解软件开发涉及到的两个概念：内聚和耦合。 内聚：软件中各个功能模块内部的功能联系。 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。 软件设计原则：高内聚低耦合。 高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。 低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。 程序中高内聚的体现： EmpServiceA类中只编写了和员工相关的逻辑处理代码 程序中耦合代码的体现： 把业务类变为EmpServiceB时，需要修改controller层中的代码 高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。 2.2 解耦思路之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后， 我们还需要修改controller层的代码。 那应该怎么解耦呢？ 1 首先不能在EmpController中使用new对象。代码如下： 1234567891011121314@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { // 业务层对象 private IEmployeeService employeeService; @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} 2 此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？ 3 我们的解决思路是： 提供一个容器，容器中存储一些对象(例：EmployeeServiceImplX对象) controller程序从容器中获取 EmployeeServiceImplX 类型的对象 我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念： 控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。 对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器 依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。 程序运行时需要某个资源，此时容器就为其提供这个资源。 例：EmployeeController程序运行时需要EmployeeServiceImplX 对象，Spring容器就为其提供并注入EmployeeServiceImplX 对象 IOC容器中创建、管理的对象，称之为：bean对象 3、IOC&amp;DI上面我们引出了Spring中IOC和DI的基本概念，下面我们就来具体学习下IOC和DI的代码实现。 3.1 IOC&amp;DI入门任务：完成Controller层、Service层、Dao层的代码解耦 思路： 删除Controller层、Service层中new对象的代码 Service层及Dao层的实现类，交给IOC容器管理 为Controller和Service注入运行时依赖的对象 Controller程序中注入依赖的Service层对象 Service程序中注入依赖的Dao层对象 第1步：删除Controller层、Service层中new对象的代码 第2步：Service层及Dao层的实现类，交给IOC容器管理 使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理 第3步：为Controller及Service注入运行时依赖的对象 使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象 完整的三层代码： Controller层： 1234567891011121314@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private IEmployeeService employeeService; @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} Service层： 12345678910111213141516@Component // 将当前对象交给IOC容器管理,成为IOC容器的beanpublic class EmployeeServiceImplA implements IEmployeeService { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private IEmployeeDao employeeDao; @Override public List&lt;Employee&gt; list() { List&lt;Employee&gt; employees = employeeDao.selectAll(); employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); return employees; }} Dao层： 123456789@Component //将当前对象交给IOC容器管理,成为IOC容器的beanpublic class EmployeeDaoImplA implements IEmployeeDao { @Override public List&lt;Employee&gt; selectAll() { String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); return employees; }} 运行测试： 启动SpringBoot引导类，打开浏览器，输入：http://localhost:8080/emp.html 3.2 IOC详解通过IOC和DI的入门程序呢，我们已经基本了解了IOC和DI的基础操作。接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。 3.3.2.1 bean的声明前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。 在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component 而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解： @Controller （标注在控制层类上） @Service （标注在业务层类上） @Repository （标注在数据访问层类上） 修改入门案例代码： Controller层： 1234567891011121314@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController { @Autowired // 运行时,从IOC容器中获取该类型对象,赋值给该变量 private IEmployeeService employeeService; @RequestMapping(&quot;/list&quot;) public Result list(){ //1 调用service层, 获取数据 List&lt;Employee&gt; employees = employeeService.list(); //2 响应数据 return Result.success(employees); }} Service层： 12345678910111213141516@Servicepublic class EmployeeServiceImplA implements IEmployeeService { @Autowired private IEmployeeDao employeeDao; @Override public List&lt;Employee&gt; list() { List&lt;Employee&gt; employees = employeeDao.selectAll(); employees.stream().forEach(emp -&gt; { String imageName = emp.getImage(); emp.setImage(&quot;/imgs/&quot; + imageName); }); return employees; }} Dao层： 123456789@Repositorypublic class EmployeeDaoImplA implements IEmployeeDao { @Override public List&lt;Employee&gt; selectAll() { String file = this.getClass().getClassLoader().getResource(&quot;emps.xml&quot;).getFile(); List&lt;Employee&gt; employees = XmlParserUtils.parse(file, Employee.class); return employees; }} 要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一： 注解 说明 位置 @Controller @Component的衍生注解 标注在控制器类上 @Service @Component的衍生注解 标注在业务类上 @Repository @Component的衍生注解 标注在数据访问类上（由于与mybatis整合，用的少） @Component 声明bean的基础注解 不属于以上三类时，用此注解 在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。 注意事项: 声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。 3.3.2.2 组件扫描问题：使用前面学习的四个注解声明的bean，一定会生效吗？ 答案：不一定。（原因：bean想要生效，还需要被组件扫描） 下面我们通过修改项目工程的目录结构，来测试bean对象是否生效： 运行程序后，报错： 为什么没有找到bean对象呢？ 使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描 @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，==默认扫描的范围是SpringBoot启动类所在包及其子包==。 解决方案：手动添加@ComponentScan注解，指定要扫描的包 （==仅做了解，不推荐==） 推荐做法（如下图）： 将我们定义的controller，service，dao这些包呢，都放在引导类所在包cn.wolfcode的子包下，这样我们定义的bean就会被自动的扫描到 3.3 DI详解上一小节我们讲解了控制反转IOC的细节，接下来呢，我们学习依赖注解DI的细节。 依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。 在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。 @Autowired注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作） 入门程序举例：在EmployeeController运行的时候，就要到IOC容器当中去查找 IEmployeeService 这个类型的对象，而我们的IOC容器中刚好有一个IEmployeeService 这个类型的对象，所以就找到了这个类型的对象完成注入操作。 那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？ 程序运行会报错 如何解决上述问题呢？Spring提供了以下几种解决方案： @Primary @Qualifier @Resource 使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。 使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用 使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。 面试题 ： @Autowird 与 @Resource的区别 @Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解 @Autowired 默认是按照类型注入，而@Resource是按照名称注入","link":"/2024/06/20/SpringBootWeb%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/"},{"title":"Spring AI Alibaba总结","text":"对话模型(Chat Model)对话模型（Chat Model）接收一系列消息（Message）作为输入，与模型 LLM 服务进行交互，并接收返回的聊天消息（Chat Message）作为输出。相比于普通的程序输入，模型的输入与输出消息（Message）不止支持纯字符文本，还支持包括语音、图片、视频等作为输入输出。同时，在 Spring AI Alibaba 中，消息中还支持包含不同的角色，帮助底层模型区分来自模型、用户和系统指令等的不同消息。 提示（Prompt）Prompt 作为语言基础输入的基础，指导 AI 模型生成特定的输出。每个文本输入都有其角色。例如，系统角色用于告知模型如何行为并设定交互的背景。还有用户角色，通常是来自用户的输入。 嵌入（Embedding）嵌入（Embedding）是文本、图像或视频的数值表示，能够捕捉输入之间的关系，Embedding通过将文本、图像和视频转换为称为向量（Vector）的浮点数数组来工作。这些向量旨在捕捉文本、图像和视频的含义，Embedding数组的长度称为向量的维度。 Embedding在实际应用中，特别是在检索增强生成（RAG）模式中，具有重要意义。它们使数据能够在语义空间中表示为点，这类似于欧几里得几何的二维空间，但在更高的维度中。这意味着，就像欧几里得几何中平面上的点可以根据其坐标的远近关系而接近或远离一样，在语义空间中，点的接近程度反映了意义的相似性。关于相似主题的句子在这个多维空间中的位置较近，就像图表上彼此靠近的点。 您可以将这个语义空间视为一个向量。 Tokentoken是 AI 模型工作原理的基石。输入时，模型将单词转换为token。输出时，它们将token转换回单词。 在英语中，一个token大约对应一个单词的 75%。作为参考，莎士比亚的全集总共约 90 万个单词，翻译过来大约有 120 万个token。 也许更重要的是 “token = 金钱”。在托管 AI 模型的背景下，您的费用由使用的token数量决定。输入和输出都会影响总token数量。 此外，模型还受到 token 限制，这会限制单个 API 调用中处理的文本量。此阈值通常称为“上下文窗口”。模型不会处理超出此限制的任何文本。 将您的数据和 API 引入 AI 模型如何让人工智能模型与不在训练集中的数据一同工作？ 请注意，GPT 3.5/4.0 数据集仅支持截止到 2021 年 9 月之前的数据。因此，该模型表示它不知道该日期之后的知识，因此它无法很好的应对需要用最新知识才能回答的问题。一个有趣的小知识是，这个数据集大约有 650GB。 有三种技术可以定制 AI 模型以整合您的数据： Fine Tuning 微调：这种传统的机器学习技术涉及定制模型并更改其内部权重。然而，即使对于机器学习专家来说，这是一个具有挑战性的过程，而且由于 GPT 等模型的大小，它极其耗费资源。此外，有些模型可能不提供此选项。 Prompt Stuffing 提示词填充：一种更实用的替代方案是将您的数据嵌入到提供给模型的提示中。考虑到模型的令牌限制，我们需要具备过滤相关数据的能力，并将过滤出的数据填充到在模型交互的上下文窗口中，这种方法俗称“提示词填充”。Spring AI 库可帮助您基于“提示词填充” 技术，也称为检索增强生成 (RAG)实现解决方案。 Function Calling：此技术允许注册自定义的用户函数，将大型语言模型连接到外部系统的 API。Spring AI 大大简化了支持函数调用所需编写的代码。 检索增强生成（RAG）一种称为检索增强生成 (RAG) 的技术已经出现，RAG为 AI 模型提供额外的知识输入，以辅助模型更好的回答问题。 该方法涉及批处理式的编程模型，其中涉及到：从文档中读取非结构化数据、对其进行转换、然后将其写入矢量数据库。从高层次上讲，这是一个 ETL（提取、转换和加载）管道。矢量数据库则用于 RAG 技术的检索部分。 在将非结构化数据加载到矢量数据库的过程中，最重要的转换之一是将原始文档拆分成较小的部分。将原始文档拆分成较小部分的过程有两个重要步骤： 将文档拆分成几部分，同时保留内容的语义边界。例如，对于包含段落和表格的文档，应避免在段落或表格中间拆分文档；对于代码，应避免在方法实现的中间拆分代码。 将文档的各部分进一步拆分成大小仅为 AI 模型令牌 token 限制的一小部分的部分。 RAG 的下一个阶段是处理用户输入。当用户的问题需要由 AI 模型回答时，问题和所有“类似”的文档片段都会被放入发送给 AI 模型的提示中。这就是使用矢量数据库的原因，它非常擅长查找具有一定相似度的“类似”内容。 ETL 管道 提供了有关协调从数据源提取数据并将其存储在结构化向量存储中的流程的更多信息，确保在将数据传递给 AI 模型时数据具有最佳的检索格式。 ChatClient - RAG 解释了如何使用QuestionAnswerAdvisor Advisor 在您的应用程序中启用 RAG 功能。 函数调用（Function Calling）大型语言模型 (LLM) 在训练后即被冻结，导致知识陈旧，并且无法访问或修改外部数据。 Function Calling机制解决了这些缺点，它允许您注册自己的函数，以将大型语言模型连接到外部系统的 API。这些系统可以为 LLM 提供实时数据并代表它们执行数据处理操作。 Spring AI 大大简化了您需要编写的代码以支持函数调用。它为您处理函数调用对话。您可以将函数以一个Bean的形式供模型调用，@Bean然后在提示选项中提供该函数的 bean 名称以激活该函数。此外，您可以在单个提示中定义和引用多个函数。 （1）执行聊天请求并发送函数定义信息。后者提供name（description例如，解释模型何时应调用该函数）和input parameters（例如，函数的输入参数模式）。 （2）当模型决定调用该函数时，它将使用输入参数调用该函数，并将输出返回给模型。 （3）Spring AI 为您处理此对话。它将函数调用分派给适当的函数，并将结果返回给模型。 （4）模型可以执行多个函数调用来检索所需的所有信息。 （5）一旦获取了所有需要的信息，模型就会生成响应。 顾问（Advisors）Spring AI ChatClient 的一个关键特性是 Advisor API。这是一个拦截器链设计模式，允许你通过注入检索数据（Retrieval Context）和对话历史（Chat Memory）来修改传入的 Prompt。 Spring AI Alibaba 中的 Advisors 是框架提供的核心组件之一，用于拦截、修改和增强与大语言模型（LLM）的交互流程。其设计灵感来源于 Spring AOP 的 Advisor，但作用对象为 AI 模型请求和响应，而非传统业务方法。以下是其核心特性和应用场景的详细解析： 一、Advisor 的核心概念 功能定位 拦截与增强：Advisor 通过拦截 AdvisedRequest 和 AdvisedResponse，实现对模型输入（Prompt）和输出（ChatResponse）的修改或增强，例如添加日志、上下文记忆、敏感词过滤等2,3。 链式调用：多个 Advisor 按优先级（getOrder() 值）组成链式结构，依次处理请求，最后将请求发送给 LLM2。 分类 非流式 Advisor（CallAroundAdvisor）：适用于同步调用场景，如日志记录、权限校验。 流式 Advisor（StreamAroundAdvisor）：用于流式响应（如 Flux&lt;AdvisedResponse&gt;），支持实时处理部分生成结果2。 二、内置 Advisor 及功能Spring AI Alibaba 提供多种开箱即用的 Advisor，覆盖常见需求： 会话记忆类 ** 1MessageChatMemoryAdvisor **：将用户提问和模型回答存入内存，实现多轮对话上下文管理。例如： 1234@BeanChatClient chatClient(ChatClient.Builder builder, ChatMemory memory) { return builder.defaultAdvisors(new MessageChatMemoryAdvisor(memory)).build();} 调用时需指定 1chatId 区分不同会话 3,5 。 **PromptChatMemoryAdvisor**：将历史会话嵌入系统提示词，兼容不支持上下文的模型2。 **VectorStoreChatMemoryAdvisor**：基于向量数据库（如 SimpleVectorStore）持久化会话，支持长期记忆和检索2。 检索增强类 **QuestionAnswerAdvisor**：结合 RAG（检索增强生成），从外部文档库检索相关内容并注入提示词，提升回答准确性2,4。 安全与日志类 **SafeGuardAdvisor**：拦截敏感词（如违禁词列表），阻止违规请求继续处理2。 **SimpleLoggerAdvisor**：记录请求和响应的日志，便于调试3,4。 三、Advisor 的配置与使用 基础配置 通过 1ChatClient.Builder 注入 Advisor： 1234567@BeanChatClient chatClient(ChatClient.Builder builder) { return builder.defaultAdvisors( new SimpleLoggerAdvisor(), new MessageChatMemoryAdvisor(new InMemoryChatMemory()) ).build();} 3,5 动态调用 在每次请求中动态指定 Advisor 参数（如会话 ID）： 123chatClient.prompt(input) .advisors(a -&gt; a.param(&quot;chatMemoryConversationId&quot;, &quot;user123&quot;)) .call(); 3 自定义 Advisor 实现 CallAroundAdvisor 或 StreamAroundAdvisor 接口，覆盖 aroundCall/aroundStream 方法： 1234567public class CustomAdvisor implements CallAroundAdvisor { @Override public AdvisedResponse aroundCall(AdvisedRequest request, CallAroundAdvisorChain chain) { // 修改请求或响应 return chain.nextAroundCall(request); }} 2 四、Advisor 的应用场景 多轮对话：通过 MessageChatMemoryAdvisor 实现上下文连贯性3。 知识增强：结合 QuestionAnswerAdvisor 和 RAG，回答专业问题4。 安全合规：使用 SafeGuardAdvisor 过滤敏感内容2。 性能监控：自定义 Advisor 统计模型调用耗时5。 五、与其他组件的协同 与 ChatClient 集成：Advisor 作为模型调用的中间件，可组合使用（如记忆+检索+日志）1,5。 与 ChatMemory 结合：持久化会话到数据库或向量存储，支持长期记忆2,3。 总结Spring AI Alibaba 的 Advisor 机制通过拦截器和链式调用，为 AI 应用提供了灵活的增强能力，尤其适合需要上下文管理、安全控制或知识检索的场景。开发者可通过内置 Advisor 快速实现功能，或自定义扩展以满足复杂需求2,5。 123456789101112131415161718192021 @Bean public ChatClient chatClient(ChatModel chatModel, VectorStore vectorStore, ChatMemory chatMemory){ ChatClient client = ChatClient.builder(chatModel) //背景设定 .defaultSystem(&quot;你是一个客服,请根据用户的问题给出合适的回答&quot;) .defaultAdvisors(// QuestionAnswerAdvisor基于向量存储(VectorStore)的问答顾问// topK(4)：表示返回最相关的4个结果// similarityThresholdAll()：设置相似度阈值 new QuestionAnswerAdvisor(vectorStore, SearchRequest.builder().topK(4).similarityThresholdAll().build()),// PromptChatMemoryAdvisor：管理对话记忆的顾问// 使用ChatMemory保存对话上下文，实现多轮对话 new PromptChatMemoryAdvisor(chatMemory),// SimpleLoggerAdvisor：简单的日志记录顾问// 可能用于记录对话过程或调试信息 new SimpleLoggerAdvisor() ) .defaultTools(&quot;getOrderFunction&quot;) .build(); return client; }","link":"/2025/07/04/Spring%20AI%20Alibaba%E6%80%BB%E7%BB%93/"}],"tags":[],"categories":[],"pages":[{"title":"","text":"/* 自定义背景图片样式 */ body { background-image: url(\"/images/background.jpg\"); background-size: cover; background-position: center; background-attachment: fixed; background-repeat: no-repeat; background-color: #f5f5f5; /* 备用背景色 */ } /* 确保内容区域有透明背景，不遮挡背景图片 */ .column, .card, .navbar { background-color: rgba(255,255,255,0.9) !important; } /* 文章内容区域背景 */ .article { background-color: rgba(255,255,255,0.95) !important; } /* 侧边栏背景 */ .sidebar { background-color: rgba(255,255,255,0.9) !important; } /* 自定义文字样式 */ .navbar-logo { font-size: 1.5rem !important; font-weight: bold !important; color: #3273dc !important; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); } .navbar-logo:hover { color: #2366c1 !important; } /* 网站标题样式 */ .site-title { font-family: 'Microsoft YaHei', sans-serif !important; } /* 文章标题样式 */ .article-title { font-size: 2rem !important; font-weight: 600 !important; color: #2c3e50 !important; margin-bottom: 1rem !important; } /* 侧边栏标题样式 */ .widget-title { font-weight: 600 !important; color: #34495e !important; border-bottom: 2px solid #3273dc !important; padding-bottom: 0.5rem !important; } /* 响应式调整 */ mobile()","link":"/css/custom.css"},{"title":"","text":"博客图片资源目录背景图片 background.jpg - 博客主背景图片（请将你的背景图片重命名为此文件名并放置于此目录） 其他图片 avatar.jpg - 头像图片（已在配置中使用） 图片建议 背景图片建议使用：1920x1080分辨率或更高 格式：JPG、PNG、WebP 文件大小：建议小于2MB以提高加载速度","link":"/images/README.html"}]}